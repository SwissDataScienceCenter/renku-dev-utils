// Package session provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package session

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for BuildCompletedPartStatus.
const (
	Succeeded BuildCompletedPartStatus = "succeeded"
)

// Defines values for BuildNotCompletedPartStatus.
const (
	BuildNotCompletedPartStatusCancelled  BuildNotCompletedPartStatus = "cancelled"
	BuildNotCompletedPartStatusFailed     BuildNotCompletedPartStatus = "failed"
	BuildNotCompletedPartStatusInProgress BuildNotCompletedPartStatus = "in_progress"
)

// Defines values for BuildPatchStatus.
const (
	BuildPatchStatusCancelled BuildPatchStatus = "cancelled"
)

// Defines values for EnvironmentImageSourceBuild.
const (
	EnvironmentImageSourceBuildBuild EnvironmentImageSourceBuild = "build"
)

// Defines values for EnvironmentImageSourceImage.
const (
	Image EnvironmentImageSourceImage = "image"
)

// Defines values for EnvironmentKind.
const (
	CUSTOM EnvironmentKind = "CUSTOM"
	GLOBAL EnvironmentKind = "GLOBAL"
)

// Build defines model for Build.
type Build struct {
	// CreatedAt The date and time the resource was created (in UTC and ISO-8601 format)
	CreatedAt CreationDate `json:"created_at"`

	// EnvironmentId ULID identifier
	EnvironmentId Ulid `json:"environment_id"`

	// ErrorReason The reason why a container image build did not succeed, if available.
	ErrorReason *ErrorReason `json:"error_reason,omitempty"`

	// Id ULID identifier
	Id    Ulid `json:"id"`
	union json.RawMessage
}

// BuildCommonPart defines model for BuildCommonPart.
type BuildCommonPart struct {
	// CreatedAt The date and time the resource was created (in UTC and ISO-8601 format)
	CreatedAt CreationDate `json:"created_at"`

	// EnvironmentId ULID identifier
	EnvironmentId Ulid `json:"environment_id"`

	// ErrorReason The reason why a container image build did not succeed, if available.
	ErrorReason *ErrorReason `json:"error_reason,omitempty"`

	// Id ULID identifier
	Id Ulid `json:"id"`
}

// BuildCompletedPart defines model for BuildCompletedPart.
type BuildCompletedPart struct {
	// Result The result of a container image build
	Result BuildResult              `json:"result"`
	Status BuildCompletedPartStatus `json:"status"`
}

// BuildCompletedPartStatus defines model for BuildCompletedPart.Status.
type BuildCompletedPartStatus string

// BuildContextDir The relative path to a folder
type BuildContextDir = string

// BuildContextDirPatch The relative path to a folder
type BuildContextDirPatch = string

// BuildList A list of container image builds
type BuildList = []Build

// BuildLogs The logs of a container image build
type BuildLogs map[string]string

// BuildNotCompletedPart defines model for BuildNotCompletedPart.
type BuildNotCompletedPart struct {
	Status BuildNotCompletedPartStatus `json:"status"`
}

// BuildNotCompletedPartStatus defines model for BuildNotCompletedPart.Status.
type BuildNotCompletedPartStatus string

// BuildParameters Build parameters
type BuildParameters struct {
	// BuilderVariant Type of virtual environment manager when building custom environments.
	BuilderVariant BuilderVariant `json:"builder_variant"`

	// ContextDir The relative path to a folder
	ContextDir *BuildContextDir `json:"context_dir,omitempty"`

	// FrontendVariant User's Frontend Choice.
	FrontendVariant FrontendVariant `json:"frontend_variant"`

	// Repository A git repository URL
	Repository Repository `json:"repository"`

	// RepositoryRevision A git revision
	RepositoryRevision *RepositoryRevision `json:"repository_revision,omitempty"`
}

// BuildParametersPatch Data for updating a build
type BuildParametersPatch struct {
	// BuilderVariant Type of virtual environment manager when building custom environments.
	BuilderVariant *BuilderVariant `json:"builder_variant,omitempty"`

	// ContextDir The relative path to a folder
	ContextDir *BuildContextDirPatch `json:"context_dir,omitempty"`

	// FrontendVariant User's Frontend Choice.
	FrontendVariant *FrontendVariant `json:"frontend_variant,omitempty"`

	// Repository A git repository URL
	Repository *Repository `json:"repository,omitempty"`

	// RepositoryRevision A git revision
	RepositoryRevision *RepositoryRevisionPatch `json:"repository_revision,omitempty"`
}

// BuildParametersPost defines model for BuildParametersPost.
type BuildParametersPost struct {
	// BuilderVariant Type of virtual environment manager when building custom environments.
	BuilderVariant BuilderVariant `json:"builder_variant"`

	// ContextDir The relative path to a folder
	ContextDir             *BuildContextDir            `json:"context_dir,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceBuild `json:"environment_image_source"`

	// FrontendVariant User's Frontend Choice.
	FrontendVariant FrontendVariant `json:"frontend_variant"`

	// Repository A git repository URL
	Repository Repository `json:"repository"`

	// RepositoryRevision A git revision
	RepositoryRevision *RepositoryRevision `json:"repository_revision,omitempty"`
}

// BuildPatch The requested update of a container image build
type BuildPatch struct {
	Status *BuildPatchStatus `json:"status,omitempty"`
}

// BuildPatchStatus defines model for BuildPatch.Status.
type BuildPatchStatus string

// BuildResult The result of a container image build
type BuildResult struct {
	// CompletedAt The date and time the resource was created (in UTC and ISO-8601 format)
	CompletedAt CreationDate `json:"completed_at"`

	// Image A container image
	Image                  ContainerImage `json:"image"`
	RepositoryGitCommitSha string         `json:"repository_git_commit_sha"`
	RepositoryUrl          string         `json:"repository_url"`
}

// BuilderVariant Type of virtual environment manager when building custom environments.
type BuilderVariant = string

// ContainerImage A container image
type ContainerImage = string

// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
type CreationDate = time.Time

// DefaultUrl The default path to open in a session
type DefaultUrl = string

// Description A description for the resource
type Description = string

// DiskStorage The size of disk storage for the session, in gigabytes
type DiskStorage = int

// DiskStoragePatch defines model for DiskStoragePatch.
type DiskStoragePatch = int

// EnvVar An environment variable for the session pod
type EnvVar struct {
	Name  string  `json:"name"`
	Value *string `json:"value,omitempty"`
}

// EnvVariables Environment variables for the session pod
type EnvVariables = []EnvVar

// Environment defines model for Environment.
type Environment struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage ContainerImage `json:"container_image"`

	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// DefaultUrl The default path to open in a session
	DefaultUrl DefaultUrl `json:"default_url"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// Gid The group ID used to run the session
	Gid EnvironmentGid `json:"gid"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived *IsArchived `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port            EnvironmentPort  `json:"port"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid EnvironmentUid `json:"uid"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentArgs The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
type EnvironmentArgs = []string

// EnvironmentCommand The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
type EnvironmentCommand = []string

// EnvironmentGetInLauncher defines model for EnvironmentGetInLauncher.
type EnvironmentGetInLauncher struct {
	union json.RawMessage
}

// EnvironmentGid The group ID used to run the session
type EnvironmentGid = int

// EnvironmentId Id of the environment to use
type EnvironmentId = string

// EnvironmentIdOnlyPatch defines model for EnvironmentIdOnlyPatch.
type EnvironmentIdOnlyPatch struct {
	// Id Id of the environment to use
	Id *EnvironmentId `json:"id,omitempty"`
}

// EnvironmentIdOnlyPost defines model for EnvironmentIdOnlyPost.
type EnvironmentIdOnlyPost struct {
	// Id Id of the environment to use
	Id EnvironmentId `json:"id"`
}

// EnvironmentImageSource Source of the environment's image
type EnvironmentImageSource struct {
	union json.RawMessage
}

// EnvironmentImageSourceBuild defines model for EnvironmentImageSourceBuild.
type EnvironmentImageSourceBuild string

// EnvironmentImageSourceImage defines model for EnvironmentImageSourceImage.
type EnvironmentImageSourceImage string

// EnvironmentKind Kind of the environment
type EnvironmentKind string

// EnvironmentList A list of session environments
type EnvironmentList = []Environment

// EnvironmentMountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
type EnvironmentMountDirectory = string

// EnvironmentMountDirectoryPatch defines model for EnvironmentMountDirectoryPatch.
type EnvironmentMountDirectoryPatch = string

// EnvironmentPatch Update a session environment
type EnvironmentPatch struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage *ContainerImage `json:"container_image,omitempty"`

	// DefaultUrl The default path to open in a session
	DefaultUrl *DefaultUrl `json:"default_url,omitempty"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// Gid The group ID used to run the session
	Gid *EnvironmentGid `json:"gid,omitempty"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived     *IsArchived                     `json:"is_archived,omitempty"`
	MountDirectory *EnvironmentMountDirectoryPatch `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name *SessionName `json:"name,omitempty"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port *EnvironmentPort `json:"port,omitempty"`

	// StripPathPrefix If set to true the default url and the base path where sessions are
	// served will be removed from all URL paths before the requests reach
	// the server running in the session. So the server in the session will
	// receive HTTP requests whose base path will be "/". However this will
	// not work unless the server running inside the session can be made
	// aware that paths are rewritten. For example, if the application/server
	// running in the session serves a HTML page that then loads javascript
	// and CSS, the path where these assets should be loaded from in the browser
	// will not be "/" but it has to include the prefix that was stripped. And
	// the server from the session that generated the HTML page needs to know
	// what is the full base path (including the part that was stripped) so that
	// it can make the URLs to such assets be reachable from the browser.
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid              *EnvironmentUid                   `json:"uid,omitempty"`
	WorkingDirectory *EnvironmentWorkingDirectoryPatch `json:"working_directory,omitempty"`
}

// EnvironmentPatchInLauncher defines model for EnvironmentPatchInLauncher.
type EnvironmentPatchInLauncher struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// BuildParameters Data for updating a build
	BuildParameters *BuildParametersPatch `json:"build_parameters,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage *ContainerImage `json:"container_image,omitempty"`

	// DefaultUrl The default path to open in a session
	DefaultUrl *DefaultUrl `json:"default_url,omitempty"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// EnvironmentImageSource Source of the environment's image
	EnvironmentImageSource *EnvironmentImageSource `json:"environment_image_source,omitempty"`

	// EnvironmentKind Kind of the environment
	EnvironmentKind *EnvironmentKind `json:"environment_kind,omitempty"`

	// Gid The group ID used to run the session
	Gid *EnvironmentGid `json:"gid,omitempty"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived     *IsArchived                     `json:"is_archived,omitempty"`
	MountDirectory *EnvironmentMountDirectoryPatch `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name *SessionName `json:"name,omitempty"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port *EnvironmentPort `json:"port,omitempty"`

	// StripPathPrefix If set to true the default url and the base path where sessions are
	// served will be removed from all URL paths before the requests reach
	// the server running in the session. So the server in the session will
	// receive HTTP requests whose base path will be "/". However this will
	// not work unless the server running inside the session can be made
	// aware that paths are rewritten. For example, if the application/server
	// running in the session serves a HTML page that then loads javascript
	// and CSS, the path where these assets should be loaded from in the browser
	// will not be "/" but it has to include the prefix that was stripped. And
	// the server from the session that generated the HTML page needs to know
	// what is the full base path (including the part that was stripped) so that
	// it can make the URLs to such assets be reachable from the browser.
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid              *EnvironmentUid                   `json:"uid,omitempty"`
	WorkingDirectory *EnvironmentWorkingDirectoryPatch `json:"working_directory,omitempty"`
}

// EnvironmentPort The TCP port (on any container in the session) where user requests will be routed to from the ingress
type EnvironmentPort = int

// EnvironmentPost Data required to create a session environment
type EnvironmentPost struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage ContainerImage `json:"container_image"`
	DefaultUrl     *DefaultUrl    `json:"default_url,omitempty"`

	// Description A description for the resource
	Description            *Description                `json:"description,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceImage `json:"environment_image_source"`
	Gid                    *EnvironmentGid             `json:"gid,omitempty"`
	IsArchived             *IsArchived                 `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name            SessionName      `json:"name"`
	Port            *EnvironmentPort `json:"port,omitempty"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`
	Uid             *EnvironmentUid  `json:"uid,omitempty"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentPostInLauncher defines model for EnvironmentPostInLauncher.
type EnvironmentPostInLauncher struct {
	union json.RawMessage
}

// EnvironmentPostInLauncherHelper defines model for EnvironmentPostInLauncherHelper.
type EnvironmentPostInLauncherHelper struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage ContainerImage `json:"container_image"`
	DefaultUrl     *DefaultUrl    `json:"default_url,omitempty"`

	// Description A description for the resource
	Description            *Description                `json:"description,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceImage `json:"environment_image_source"`

	// EnvironmentKind Kind of the environment
	EnvironmentKind EnvironmentKind `json:"environment_kind"`
	Gid             *EnvironmentGid `json:"gid,omitempty"`
	IsArchived      *IsArchived     `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name            SessionName      `json:"name"`
	Port            *EnvironmentPort `json:"port,omitempty"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`
	Uid             *EnvironmentUid  `json:"uid,omitempty"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentUid The user ID used to run the session
type EnvironmentUid = int

// EnvironmentWithBuildGet defines model for EnvironmentWithBuildGet.
type EnvironmentWithBuildGet struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// BuildParameters Build parameters
	BuildParameters BuildParameters `json:"build_parameters"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage *ContainerImage `json:"container_image,omitempty"`

	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// DefaultUrl The default path to open in a session
	DefaultUrl DefaultUrl `json:"default_url"`

	// Description A description for the resource
	Description            *Description                `json:"description,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceBuild `json:"environment_image_source"`
	EnvironmentKind        EnvironmentKind             `json:"environment_kind"`

	// Gid The group ID used to run the session
	Gid EnvironmentGid `json:"gid"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived *IsArchived `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port            EnvironmentPort  `json:"port"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid EnvironmentUid `json:"uid"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentWithImageGet defines model for EnvironmentWithImageGet.
type EnvironmentWithImageGet struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage ContainerImage `json:"container_image"`

	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// DefaultUrl The default path to open in a session
	DefaultUrl DefaultUrl `json:"default_url"`

	// Description A description for the resource
	Description            *Description                `json:"description,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceImage `json:"environment_image_source"`
	EnvironmentKind        EnvironmentKind             `json:"environment_kind"`

	// Gid The group ID used to run the session
	Gid EnvironmentGid `json:"gid"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived *IsArchived `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port            EnvironmentPort  `json:"port"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid EnvironmentUid `json:"uid"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentWithoutContainerImage A Renku 2.0 session environment
type EnvironmentWithoutContainerImage struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// DefaultUrl The default path to open in a session
	DefaultUrl DefaultUrl `json:"default_url"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// Gid The group ID used to run the session
	Gid EnvironmentGid `json:"gid"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived *IsArchived `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port            EnvironmentPort  `json:"port"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid EnvironmentUid `json:"uid"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentWorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
type EnvironmentWorkingDirectory = string

// EnvironmentWorkingDirectoryPatch defines model for EnvironmentWorkingDirectoryPatch.
type EnvironmentWorkingDirectoryPatch = string

// ErrorReason The reason why a container image build did not succeed, if available.
type ErrorReason = string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error struct {
		Code    int     `json:"code"`
		Detail  *string `json:"detail,omitempty"`
		Message string  `json:"message"`
	} `json:"error"`
}

// FrontendVariant User's Frontend Choice.
type FrontendVariant = string

// IsArchived Whether this environment is archived and not for use in new projects or not
type IsArchived = bool

// Repository A git repository URL
type Repository = string

// RepositoryRevision A git revision
type RepositoryRevision = string

// RepositoryRevisionPatch A git revision
type RepositoryRevisionPatch = string

// ResourceClassId The identifier of a resource class
type ResourceClassId = int

// SessionLauncher A Renku 2.0 session definition and metadata
type SessionLauncher struct {
	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// DiskStorage The size of disk storage for the session, in gigabytes
	DiskStorage *DiskStorage `json:"disk_storage,omitempty"`

	// EnvVariables Environment variables for the session pod
	EnvVariables *EnvVariables            `json:"env_variables,omitempty"`
	Environment  EnvironmentGetInLauncher `json:"environment"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// ProjectId ULID identifier
	ProjectId Ulid `json:"project_id"`

	// ResourceClassId The identifier of a resource class
	ResourceClassId *ResourceClassId `json:"resource_class_id"`
}

// SessionLauncherPatch Update a session launcher
type SessionLauncherPatch struct {
	// Description A description for the resource
	Description *Description      `json:"description,omitempty"`
	DiskStorage *DiskStoragePatch `json:"disk_storage"`

	// EnvVariables Environment variables for the session pod
	EnvVariables *EnvVariables                     `json:"env_variables,omitempty"`
	Environment  *SessionLauncherPatch_Environment `json:"environment,omitempty"`

	// Name Renku session name
	Name *SessionName `json:"name,omitempty"`

	// ResourceClassId The identifier of a resource class
	ResourceClassId *ResourceClassId `json:"resource_class_id"`
}

// SessionLauncherPatch_Environment defines model for SessionLauncherPatch.Environment.
type SessionLauncherPatch_Environment struct {
	union json.RawMessage
}

// SessionLauncherPost Data required to create a session launcher
type SessionLauncherPost struct {
	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// DiskStorage The size of disk storage for the session, in gigabytes
	DiskStorage *DiskStorage `json:"disk_storage,omitempty"`

	// EnvVariables Environment variables for the session pod
	EnvVariables *EnvVariables                   `json:"env_variables,omitempty"`
	Environment  SessionLauncherPost_Environment `json:"environment"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// ProjectId ULID identifier
	ProjectId Ulid `json:"project_id"`

	// ResourceClassId The identifier of a resource class
	ResourceClassId *ResourceClassId `json:"resource_class_id"`
}

// SessionLauncherPost_Environment defines model for SessionLauncherPost.Environment.
type SessionLauncherPost_Environment struct {
	union json.RawMessage
}

// SessionLaunchersList A list of Renku session launchers
type SessionLaunchersList = []SessionLauncher

// SessionName Renku session name
type SessionName = string

// StripPathPrefix If set to true the default url and the base path where sessions are
// served will be removed from all URL paths before the requests reach
// the server running in the session. So the server in the session will
// receive HTTP requests whose base path will be "/". However this will
// not work unless the server running inside the session can be made
// aware that paths are rewritten. For example, if the application/server
// running in the session serves a HTML page that then loads javascript
// and CSS, the path where these assets should be loaded from in the browser
// will not be "/" but it has to include the prefix that was stripped. And
// the server from the session that generated the HTML page needs to know
// what is the full base path (including the part that was stripped) so that
// it can make the URLs to such assets be reachable from the browser.
type StripPathPrefix = bool

// Ulid ULID identifier
type Ulid = string

// Error defines model for Error.
type Error = ErrorResponse

// GetBuildsBuildIdLogsParams defines parameters for GetBuildsBuildIdLogs.
type GetBuildsBuildIdLogsParams struct {
	// MaxLines The maximum number of most-recent lines to return for each container
	MaxLines *int `form:"max_lines,omitempty" json:"max_lines,omitempty"`
}

// GetEnvironmentsParams defines parameters for GetEnvironments.
type GetEnvironmentsParams struct {
	GetEnvironmentParams *struct {
		// IncludeArchived Whether to return archived environments or not
		IncludeArchived *bool `json:"include_archived,omitempty"`
	} `form:"get_environment_params,omitempty" json:"get_environment_params,omitempty"`
}

// PatchBuildsBuildIdJSONRequestBody defines body for PatchBuildsBuildId for application/json ContentType.
type PatchBuildsBuildIdJSONRequestBody = BuildPatch

// PostEnvironmentsJSONRequestBody defines body for PostEnvironments for application/json ContentType.
type PostEnvironmentsJSONRequestBody = EnvironmentPost

// PatchEnvironmentsEnvironmentIdJSONRequestBody defines body for PatchEnvironmentsEnvironmentId for application/json ContentType.
type PatchEnvironmentsEnvironmentIdJSONRequestBody = EnvironmentPatch

// PostSessionLaunchersJSONRequestBody defines body for PostSessionLaunchers for application/json ContentType.
type PostSessionLaunchersJSONRequestBody = SessionLauncherPost

// PatchSessionLaunchersLauncherIdJSONRequestBody defines body for PatchSessionLaunchersLauncherId for application/json ContentType.
type PatchSessionLaunchersLauncherIdJSONRequestBody = SessionLauncherPatch

// AsBuildNotCompletedPart returns the union data inside the Build as a BuildNotCompletedPart
func (t Build) AsBuildNotCompletedPart() (BuildNotCompletedPart, error) {
	var body BuildNotCompletedPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBuildNotCompletedPart overwrites any union data inside the Build as the provided BuildNotCompletedPart
func (t *Build) FromBuildNotCompletedPart(v BuildNotCompletedPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBuildNotCompletedPart performs a merge with any union data inside the Build, using the provided BuildNotCompletedPart
func (t *Build) MergeBuildNotCompletedPart(v BuildNotCompletedPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBuildCompletedPart returns the union data inside the Build as a BuildCompletedPart
func (t Build) AsBuildCompletedPart() (BuildCompletedPart, error) {
	var body BuildCompletedPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBuildCompletedPart overwrites any union data inside the Build as the provided BuildCompletedPart
func (t *Build) FromBuildCompletedPart(v BuildCompletedPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBuildCompletedPart performs a merge with any union data inside the Build, using the provided BuildCompletedPart
func (t *Build) MergeBuildCompletedPart(v BuildCompletedPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Build) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["created_at"], err = json.Marshal(t.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["environment_id"], err = json.Marshal(t.EnvironmentId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'environment_id': %w", err)
	}

	if t.ErrorReason != nil {
		object["error_reason"], err = json.Marshal(t.ErrorReason)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error_reason': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Build) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
	}

	if raw, found := object["environment_id"]; found {
		err = json.Unmarshal(raw, &t.EnvironmentId)
		if err != nil {
			return fmt.Errorf("error reading 'environment_id': %w", err)
		}
	}

	if raw, found := object["error_reason"]; found {
		err = json.Unmarshal(raw, &t.ErrorReason)
		if err != nil {
			return fmt.Errorf("error reading 'error_reason': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	return err
}

// AsEnvironmentWithImageGet returns the union data inside the EnvironmentGetInLauncher as a EnvironmentWithImageGet
func (t EnvironmentGetInLauncher) AsEnvironmentWithImageGet() (EnvironmentWithImageGet, error) {
	var body EnvironmentWithImageGet
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentWithImageGet overwrites any union data inside the EnvironmentGetInLauncher as the provided EnvironmentWithImageGet
func (t *EnvironmentGetInLauncher) FromEnvironmentWithImageGet(v EnvironmentWithImageGet) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentWithImageGet performs a merge with any union data inside the EnvironmentGetInLauncher, using the provided EnvironmentWithImageGet
func (t *EnvironmentGetInLauncher) MergeEnvironmentWithImageGet(v EnvironmentWithImageGet) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentWithBuildGet returns the union data inside the EnvironmentGetInLauncher as a EnvironmentWithBuildGet
func (t EnvironmentGetInLauncher) AsEnvironmentWithBuildGet() (EnvironmentWithBuildGet, error) {
	var body EnvironmentWithBuildGet
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentWithBuildGet overwrites any union data inside the EnvironmentGetInLauncher as the provided EnvironmentWithBuildGet
func (t *EnvironmentGetInLauncher) FromEnvironmentWithBuildGet(v EnvironmentWithBuildGet) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentWithBuildGet performs a merge with any union data inside the EnvironmentGetInLauncher, using the provided EnvironmentWithBuildGet
func (t *EnvironmentGetInLauncher) MergeEnvironmentWithBuildGet(v EnvironmentWithBuildGet) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentGetInLauncher) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentGetInLauncher) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentImageSourceImage returns the union data inside the EnvironmentImageSource as a EnvironmentImageSourceImage
func (t EnvironmentImageSource) AsEnvironmentImageSourceImage() (EnvironmentImageSourceImage, error) {
	var body EnvironmentImageSourceImage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentImageSourceImage overwrites any union data inside the EnvironmentImageSource as the provided EnvironmentImageSourceImage
func (t *EnvironmentImageSource) FromEnvironmentImageSourceImage(v EnvironmentImageSourceImage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentImageSourceImage performs a merge with any union data inside the EnvironmentImageSource, using the provided EnvironmentImageSourceImage
func (t *EnvironmentImageSource) MergeEnvironmentImageSourceImage(v EnvironmentImageSourceImage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentImageSourceBuild returns the union data inside the EnvironmentImageSource as a EnvironmentImageSourceBuild
func (t EnvironmentImageSource) AsEnvironmentImageSourceBuild() (EnvironmentImageSourceBuild, error) {
	var body EnvironmentImageSourceBuild
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentImageSourceBuild overwrites any union data inside the EnvironmentImageSource as the provided EnvironmentImageSourceBuild
func (t *EnvironmentImageSource) FromEnvironmentImageSourceBuild(v EnvironmentImageSourceBuild) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentImageSourceBuild performs a merge with any union data inside the EnvironmentImageSource, using the provided EnvironmentImageSourceBuild
func (t *EnvironmentImageSource) MergeEnvironmentImageSourceBuild(v EnvironmentImageSourceBuild) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentImageSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentImageSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentPostInLauncherHelper returns the union data inside the EnvironmentPostInLauncher as a EnvironmentPostInLauncherHelper
func (t EnvironmentPostInLauncher) AsEnvironmentPostInLauncherHelper() (EnvironmentPostInLauncherHelper, error) {
	var body EnvironmentPostInLauncherHelper
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentPostInLauncherHelper overwrites any union data inside the EnvironmentPostInLauncher as the provided EnvironmentPostInLauncherHelper
func (t *EnvironmentPostInLauncher) FromEnvironmentPostInLauncherHelper(v EnvironmentPostInLauncherHelper) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentPostInLauncherHelper performs a merge with any union data inside the EnvironmentPostInLauncher, using the provided EnvironmentPostInLauncherHelper
func (t *EnvironmentPostInLauncher) MergeEnvironmentPostInLauncherHelper(v EnvironmentPostInLauncherHelper) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBuildParametersPost returns the union data inside the EnvironmentPostInLauncher as a BuildParametersPost
func (t EnvironmentPostInLauncher) AsBuildParametersPost() (BuildParametersPost, error) {
	var body BuildParametersPost
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBuildParametersPost overwrites any union data inside the EnvironmentPostInLauncher as the provided BuildParametersPost
func (t *EnvironmentPostInLauncher) FromBuildParametersPost(v BuildParametersPost) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBuildParametersPost performs a merge with any union data inside the EnvironmentPostInLauncher, using the provided BuildParametersPost
func (t *EnvironmentPostInLauncher) MergeBuildParametersPost(v BuildParametersPost) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentPostInLauncher) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentPostInLauncher) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentPatchInLauncher returns the union data inside the SessionLauncherPatch_Environment as a EnvironmentPatchInLauncher
func (t SessionLauncherPatch_Environment) AsEnvironmentPatchInLauncher() (EnvironmentPatchInLauncher, error) {
	var body EnvironmentPatchInLauncher
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentPatchInLauncher overwrites any union data inside the SessionLauncherPatch_Environment as the provided EnvironmentPatchInLauncher
func (t *SessionLauncherPatch_Environment) FromEnvironmentPatchInLauncher(v EnvironmentPatchInLauncher) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentPatchInLauncher performs a merge with any union data inside the SessionLauncherPatch_Environment, using the provided EnvironmentPatchInLauncher
func (t *SessionLauncherPatch_Environment) MergeEnvironmentPatchInLauncher(v EnvironmentPatchInLauncher) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentIdOnlyPatch returns the union data inside the SessionLauncherPatch_Environment as a EnvironmentIdOnlyPatch
func (t SessionLauncherPatch_Environment) AsEnvironmentIdOnlyPatch() (EnvironmentIdOnlyPatch, error) {
	var body EnvironmentIdOnlyPatch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentIdOnlyPatch overwrites any union data inside the SessionLauncherPatch_Environment as the provided EnvironmentIdOnlyPatch
func (t *SessionLauncherPatch_Environment) FromEnvironmentIdOnlyPatch(v EnvironmentIdOnlyPatch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentIdOnlyPatch performs a merge with any union data inside the SessionLauncherPatch_Environment, using the provided EnvironmentIdOnlyPatch
func (t *SessionLauncherPatch_Environment) MergeEnvironmentIdOnlyPatch(v EnvironmentIdOnlyPatch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SessionLauncherPatch_Environment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SessionLauncherPatch_Environment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentPostInLauncher returns the union data inside the SessionLauncherPost_Environment as a EnvironmentPostInLauncher
func (t SessionLauncherPost_Environment) AsEnvironmentPostInLauncher() (EnvironmentPostInLauncher, error) {
	var body EnvironmentPostInLauncher
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentPostInLauncher overwrites any union data inside the SessionLauncherPost_Environment as the provided EnvironmentPostInLauncher
func (t *SessionLauncherPost_Environment) FromEnvironmentPostInLauncher(v EnvironmentPostInLauncher) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentPostInLauncher performs a merge with any union data inside the SessionLauncherPost_Environment, using the provided EnvironmentPostInLauncher
func (t *SessionLauncherPost_Environment) MergeEnvironmentPostInLauncher(v EnvironmentPostInLauncher) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentIdOnlyPost returns the union data inside the SessionLauncherPost_Environment as a EnvironmentIdOnlyPost
func (t SessionLauncherPost_Environment) AsEnvironmentIdOnlyPost() (EnvironmentIdOnlyPost, error) {
	var body EnvironmentIdOnlyPost
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentIdOnlyPost overwrites any union data inside the SessionLauncherPost_Environment as the provided EnvironmentIdOnlyPost
func (t *SessionLauncherPost_Environment) FromEnvironmentIdOnlyPost(v EnvironmentIdOnlyPost) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentIdOnlyPost performs a merge with any union data inside the SessionLauncherPost_Environment, using the provided EnvironmentIdOnlyPost
func (t *SessionLauncherPost_Environment) MergeEnvironmentIdOnlyPost(v EnvironmentIdOnlyPost) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SessionLauncherPost_Environment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SessionLauncherPost_Environment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetBuildsBuildId request
	GetBuildsBuildId(ctx context.Context, buildId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchBuildsBuildIdWithBody request with any body
	PatchBuildsBuildIdWithBody(ctx context.Context, buildId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchBuildsBuildId(ctx context.Context, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuildsBuildIdLogs request
	GetBuildsBuildIdLogs(ctx context.Context, buildId Ulid, params *GetBuildsBuildIdLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironments request
	GetEnvironments(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEnvironmentsWithBody request with any body
	PostEnvironmentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEnvironments(ctx context.Context, body PostEnvironmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEnvironmentsEnvironmentId request
	DeleteEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentsEnvironmentId request
	GetEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchEnvironmentsEnvironmentIdWithBody request with any body
	PatchEnvironmentsEnvironmentIdWithBody(ctx context.Context, environmentId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentsEnvironmentIdBuilds request
	GetEnvironmentsEnvironmentIdBuilds(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEnvironmentsEnvironmentIdBuilds request
	PostEnvironmentsEnvironmentIdBuilds(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectsProjectIdSessionLaunchers request
	GetProjectsProjectIdSessionLaunchers(ctx context.Context, projectId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionLaunchers request
	GetSessionLaunchers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSessionLaunchersWithBody request with any body
	PostSessionLaunchersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSessionLaunchers(ctx context.Context, body PostSessionLaunchersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSessionLaunchersLauncherId request
	DeleteSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionLaunchersLauncherId request
	GetSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSessionLaunchersLauncherIdWithBody request with any body
	PatchSessionLaunchersLauncherIdWithBody(ctx context.Context, launcherId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetBuildsBuildId(ctx context.Context, buildId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildsBuildIdRequest(c.Server, buildId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBuildsBuildIdWithBody(ctx context.Context, buildId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBuildsBuildIdRequestWithBody(c.Server, buildId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBuildsBuildId(ctx context.Context, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBuildsBuildIdRequest(c.Server, buildId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuildsBuildIdLogs(ctx context.Context, buildId Ulid, params *GetBuildsBuildIdLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildsBuildIdLogsRequest(c.Server, buildId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironments(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEnvironmentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEnvironmentsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEnvironments(ctx context.Context, body PostEnvironmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEnvironmentsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEnvironmentsEnvironmentIdRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentsEnvironmentIdRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEnvironmentsEnvironmentIdWithBody(ctx context.Context, environmentId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEnvironmentsEnvironmentIdRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEnvironmentsEnvironmentIdRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentsEnvironmentIdBuilds(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentsEnvironmentIdBuildsRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEnvironmentsEnvironmentIdBuilds(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEnvironmentsEnvironmentIdBuildsRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsProjectIdSessionLaunchers(ctx context.Context, projectId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsProjectIdSessionLaunchersRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionLaunchers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionLaunchersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSessionLaunchersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSessionLaunchersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSessionLaunchers(ctx context.Context, body PostSessionLaunchersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSessionLaunchersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSessionLaunchersLauncherIdRequest(c.Server, launcherId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionLaunchersLauncherIdRequest(c.Server, launcherId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSessionLaunchersLauncherIdWithBody(ctx context.Context, launcherId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSessionLaunchersLauncherIdRequestWithBody(c.Server, launcherId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSessionLaunchersLauncherIdRequest(c.Server, launcherId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetBuildsBuildIdRequest generates requests for GetBuildsBuildId
func NewGetBuildsBuildIdRequest(server string, buildId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/builds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchBuildsBuildIdRequest calls the generic PatchBuildsBuildId builder with application/json body
func NewPatchBuildsBuildIdRequest(server string, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchBuildsBuildIdRequestWithBody(server, buildId, "application/json", bodyReader)
}

// NewPatchBuildsBuildIdRequestWithBody generates requests for PatchBuildsBuildId with any type of body
func NewPatchBuildsBuildIdRequestWithBody(server string, buildId Ulid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/builds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBuildsBuildIdLogsRequest generates requests for GetBuildsBuildIdLogs
func NewGetBuildsBuildIdLogsRequest(server string, buildId Ulid, params *GetBuildsBuildIdLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/builds/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_lines", runtime.ParamLocationQuery, *params.MaxLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvironmentsRequest generates requests for GetEnvironments
func NewGetEnvironmentsRequest(server string, params *GetEnvironmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GetEnvironmentParams != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get_environment_params", runtime.ParamLocationQuery, *params.GetEnvironmentParams); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEnvironmentsRequest calls the generic PostEnvironments builder with application/json body
func NewPostEnvironmentsRequest(server string, body PostEnvironmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEnvironmentsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEnvironmentsRequestWithBody generates requests for PostEnvironments with any type of body
func NewPostEnvironmentsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEnvironmentsEnvironmentIdRequest generates requests for DeleteEnvironmentsEnvironmentId
func NewDeleteEnvironmentsEnvironmentIdRequest(server string, environmentId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvironmentsEnvironmentIdRequest generates requests for GetEnvironmentsEnvironmentId
func NewGetEnvironmentsEnvironmentIdRequest(server string, environmentId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchEnvironmentsEnvironmentIdRequest calls the generic PatchEnvironmentsEnvironmentId builder with application/json body
func NewPatchEnvironmentsEnvironmentIdRequest(server string, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchEnvironmentsEnvironmentIdRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewPatchEnvironmentsEnvironmentIdRequestWithBody generates requests for PatchEnvironmentsEnvironmentId with any type of body
func NewPatchEnvironmentsEnvironmentIdRequestWithBody(server string, environmentId Ulid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnvironmentsEnvironmentIdBuildsRequest generates requests for GetEnvironmentsEnvironmentIdBuilds
func NewGetEnvironmentsEnvironmentIdBuildsRequest(server string, environmentId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEnvironmentsEnvironmentIdBuildsRequest generates requests for PostEnvironmentsEnvironmentIdBuilds
func NewPostEnvironmentsEnvironmentIdBuildsRequest(server string, environmentId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectsProjectIdSessionLaunchersRequest generates requests for GetProjectsProjectIdSessionLaunchers
func NewGetProjectsProjectIdSessionLaunchersRequest(server string, projectId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/session_launchers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSessionLaunchersRequest generates requests for GetSessionLaunchers
func NewGetSessionLaunchersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSessionLaunchersRequest calls the generic PostSessionLaunchers builder with application/json body
func NewPostSessionLaunchersRequest(server string, body PostSessionLaunchersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSessionLaunchersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSessionLaunchersRequestWithBody generates requests for PostSessionLaunchers with any type of body
func NewPostSessionLaunchersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSessionLaunchersLauncherIdRequest generates requests for DeleteSessionLaunchersLauncherId
func NewDeleteSessionLaunchersLauncherIdRequest(server string, launcherId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "launcher_id", runtime.ParamLocationPath, launcherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSessionLaunchersLauncherIdRequest generates requests for GetSessionLaunchersLauncherId
func NewGetSessionLaunchersLauncherIdRequest(server string, launcherId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "launcher_id", runtime.ParamLocationPath, launcherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSessionLaunchersLauncherIdRequest calls the generic PatchSessionLaunchersLauncherId builder with application/json body
func NewPatchSessionLaunchersLauncherIdRequest(server string, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSessionLaunchersLauncherIdRequestWithBody(server, launcherId, "application/json", bodyReader)
}

// NewPatchSessionLaunchersLauncherIdRequestWithBody generates requests for PatchSessionLaunchersLauncherId with any type of body
func NewPatchSessionLaunchersLauncherIdRequestWithBody(server string, launcherId Ulid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "launcher_id", runtime.ParamLocationPath, launcherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetBuildsBuildIdWithResponse request
	GetBuildsBuildIdWithResponse(ctx context.Context, buildId Ulid, reqEditors ...RequestEditorFn) (*GetBuildsBuildIdResponse, error)

	// PatchBuildsBuildIdWithBodyWithResponse request with any body
	PatchBuildsBuildIdWithBodyWithResponse(ctx context.Context, buildId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBuildsBuildIdResponse, error)

	PatchBuildsBuildIdWithResponse(ctx context.Context, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBuildsBuildIdResponse, error)

	// GetBuildsBuildIdLogsWithResponse request
	GetBuildsBuildIdLogsWithResponse(ctx context.Context, buildId Ulid, params *GetBuildsBuildIdLogsParams, reqEditors ...RequestEditorFn) (*GetBuildsBuildIdLogsResponse, error)

	// GetEnvironmentsWithResponse request
	GetEnvironmentsWithResponse(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*GetEnvironmentsResponse, error)

	// PostEnvironmentsWithBodyWithResponse request with any body
	PostEnvironmentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEnvironmentsResponse, error)

	PostEnvironmentsWithResponse(ctx context.Context, body PostEnvironmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEnvironmentsResponse, error)

	// DeleteEnvironmentsEnvironmentIdWithResponse request
	DeleteEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*DeleteEnvironmentsEnvironmentIdResponse, error)

	// GetEnvironmentsEnvironmentIdWithResponse request
	GetEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*GetEnvironmentsEnvironmentIdResponse, error)

	// PatchEnvironmentsEnvironmentIdWithBodyWithResponse request with any body
	PatchEnvironmentsEnvironmentIdWithBodyWithResponse(ctx context.Context, environmentId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEnvironmentsEnvironmentIdResponse, error)

	PatchEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEnvironmentsEnvironmentIdResponse, error)

	// GetEnvironmentsEnvironmentIdBuildsWithResponse request
	GetEnvironmentsEnvironmentIdBuildsWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*GetEnvironmentsEnvironmentIdBuildsResponse, error)

	// PostEnvironmentsEnvironmentIdBuildsWithResponse request
	PostEnvironmentsEnvironmentIdBuildsWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*PostEnvironmentsEnvironmentIdBuildsResponse, error)

	// GetProjectsProjectIdSessionLaunchersWithResponse request
	GetProjectsProjectIdSessionLaunchersWithResponse(ctx context.Context, projectId Ulid, reqEditors ...RequestEditorFn) (*GetProjectsProjectIdSessionLaunchersResponse, error)

	// GetSessionLaunchersWithResponse request
	GetSessionLaunchersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionLaunchersResponse, error)

	// PostSessionLaunchersWithBodyWithResponse request with any body
	PostSessionLaunchersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSessionLaunchersResponse, error)

	PostSessionLaunchersWithResponse(ctx context.Context, body PostSessionLaunchersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSessionLaunchersResponse, error)

	// DeleteSessionLaunchersLauncherIdWithResponse request
	DeleteSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*DeleteSessionLaunchersLauncherIdResponse, error)

	// GetSessionLaunchersLauncherIdWithResponse request
	GetSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*GetSessionLaunchersLauncherIdResponse, error)

	// PatchSessionLaunchersLauncherIdWithBodyWithResponse request with any body
	PatchSessionLaunchersLauncherIdWithBodyWithResponse(ctx context.Context, launcherId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSessionLaunchersLauncherIdResponse, error)

	PatchSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSessionLaunchersLauncherIdResponse, error)
}

type GetBuildsBuildIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBuildsBuildIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildsBuildIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchBuildsBuildIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchBuildsBuildIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchBuildsBuildIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildsBuildIdLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildLogs
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBuildsBuildIdLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildsBuildIdLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnvironmentList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEnvironmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Environment
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostEnvironmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEnvironmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvironmentsEnvironmentIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteEnvironmentsEnvironmentIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvironmentsEnvironmentIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentsEnvironmentIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
	JSON404      *ErrorResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentsEnvironmentIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentsEnvironmentIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchEnvironmentsEnvironmentIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
	JSON404      *ErrorResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchEnvironmentsEnvironmentIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchEnvironmentsEnvironmentIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentsEnvironmentIdBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentsEnvironmentIdBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentsEnvironmentIdBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEnvironmentsEnvironmentIdBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Build
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostEnvironmentsEnvironmentIdBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEnvironmentsEnvironmentIdBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsProjectIdSessionLaunchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLaunchersList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetProjectsProjectIdSessionLaunchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsProjectIdSessionLaunchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionLaunchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLaunchersList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSessionLaunchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionLaunchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSessionLaunchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionLauncher
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostSessionLaunchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSessionLaunchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSessionLaunchersLauncherIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSessionLaunchersLauncherIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSessionLaunchersLauncherIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionLaunchersLauncherIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLauncher
	JSON404      *ErrorResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSessionLaunchersLauncherIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionLaunchersLauncherIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSessionLaunchersLauncherIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLauncher
	JSON404      *ErrorResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchSessionLaunchersLauncherIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSessionLaunchersLauncherIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBuildsBuildIdWithResponse request returning *GetBuildsBuildIdResponse
func (c *ClientWithResponses) GetBuildsBuildIdWithResponse(ctx context.Context, buildId Ulid, reqEditors ...RequestEditorFn) (*GetBuildsBuildIdResponse, error) {
	rsp, err := c.GetBuildsBuildId(ctx, buildId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildsBuildIdResponse(rsp)
}

// PatchBuildsBuildIdWithBodyWithResponse request with arbitrary body returning *PatchBuildsBuildIdResponse
func (c *ClientWithResponses) PatchBuildsBuildIdWithBodyWithResponse(ctx context.Context, buildId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBuildsBuildIdResponse, error) {
	rsp, err := c.PatchBuildsBuildIdWithBody(ctx, buildId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBuildsBuildIdResponse(rsp)
}

func (c *ClientWithResponses) PatchBuildsBuildIdWithResponse(ctx context.Context, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBuildsBuildIdResponse, error) {
	rsp, err := c.PatchBuildsBuildId(ctx, buildId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBuildsBuildIdResponse(rsp)
}

// GetBuildsBuildIdLogsWithResponse request returning *GetBuildsBuildIdLogsResponse
func (c *ClientWithResponses) GetBuildsBuildIdLogsWithResponse(ctx context.Context, buildId Ulid, params *GetBuildsBuildIdLogsParams, reqEditors ...RequestEditorFn) (*GetBuildsBuildIdLogsResponse, error) {
	rsp, err := c.GetBuildsBuildIdLogs(ctx, buildId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildsBuildIdLogsResponse(rsp)
}

// GetEnvironmentsWithResponse request returning *GetEnvironmentsResponse
func (c *ClientWithResponses) GetEnvironmentsWithResponse(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*GetEnvironmentsResponse, error) {
	rsp, err := c.GetEnvironments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentsResponse(rsp)
}

// PostEnvironmentsWithBodyWithResponse request with arbitrary body returning *PostEnvironmentsResponse
func (c *ClientWithResponses) PostEnvironmentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEnvironmentsResponse, error) {
	rsp, err := c.PostEnvironmentsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEnvironmentsResponse(rsp)
}

func (c *ClientWithResponses) PostEnvironmentsWithResponse(ctx context.Context, body PostEnvironmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEnvironmentsResponse, error) {
	rsp, err := c.PostEnvironments(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEnvironmentsResponse(rsp)
}

// DeleteEnvironmentsEnvironmentIdWithResponse request returning *DeleteEnvironmentsEnvironmentIdResponse
func (c *ClientWithResponses) DeleteEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*DeleteEnvironmentsEnvironmentIdResponse, error) {
	rsp, err := c.DeleteEnvironmentsEnvironmentId(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvironmentsEnvironmentIdResponse(rsp)
}

// GetEnvironmentsEnvironmentIdWithResponse request returning *GetEnvironmentsEnvironmentIdResponse
func (c *ClientWithResponses) GetEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*GetEnvironmentsEnvironmentIdResponse, error) {
	rsp, err := c.GetEnvironmentsEnvironmentId(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentsEnvironmentIdResponse(rsp)
}

// PatchEnvironmentsEnvironmentIdWithBodyWithResponse request with arbitrary body returning *PatchEnvironmentsEnvironmentIdResponse
func (c *ClientWithResponses) PatchEnvironmentsEnvironmentIdWithBodyWithResponse(ctx context.Context, environmentId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEnvironmentsEnvironmentIdResponse, error) {
	rsp, err := c.PatchEnvironmentsEnvironmentIdWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEnvironmentsEnvironmentIdResponse(rsp)
}

func (c *ClientWithResponses) PatchEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEnvironmentsEnvironmentIdResponse, error) {
	rsp, err := c.PatchEnvironmentsEnvironmentId(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEnvironmentsEnvironmentIdResponse(rsp)
}

// GetEnvironmentsEnvironmentIdBuildsWithResponse request returning *GetEnvironmentsEnvironmentIdBuildsResponse
func (c *ClientWithResponses) GetEnvironmentsEnvironmentIdBuildsWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*GetEnvironmentsEnvironmentIdBuildsResponse, error) {
	rsp, err := c.GetEnvironmentsEnvironmentIdBuilds(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentsEnvironmentIdBuildsResponse(rsp)
}

// PostEnvironmentsEnvironmentIdBuildsWithResponse request returning *PostEnvironmentsEnvironmentIdBuildsResponse
func (c *ClientWithResponses) PostEnvironmentsEnvironmentIdBuildsWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*PostEnvironmentsEnvironmentIdBuildsResponse, error) {
	rsp, err := c.PostEnvironmentsEnvironmentIdBuilds(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEnvironmentsEnvironmentIdBuildsResponse(rsp)
}

// GetProjectsProjectIdSessionLaunchersWithResponse request returning *GetProjectsProjectIdSessionLaunchersResponse
func (c *ClientWithResponses) GetProjectsProjectIdSessionLaunchersWithResponse(ctx context.Context, projectId Ulid, reqEditors ...RequestEditorFn) (*GetProjectsProjectIdSessionLaunchersResponse, error) {
	rsp, err := c.GetProjectsProjectIdSessionLaunchers(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsProjectIdSessionLaunchersResponse(rsp)
}

// GetSessionLaunchersWithResponse request returning *GetSessionLaunchersResponse
func (c *ClientWithResponses) GetSessionLaunchersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionLaunchersResponse, error) {
	rsp, err := c.GetSessionLaunchers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionLaunchersResponse(rsp)
}

// PostSessionLaunchersWithBodyWithResponse request with arbitrary body returning *PostSessionLaunchersResponse
func (c *ClientWithResponses) PostSessionLaunchersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSessionLaunchersResponse, error) {
	rsp, err := c.PostSessionLaunchersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSessionLaunchersResponse(rsp)
}

func (c *ClientWithResponses) PostSessionLaunchersWithResponse(ctx context.Context, body PostSessionLaunchersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSessionLaunchersResponse, error) {
	rsp, err := c.PostSessionLaunchers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSessionLaunchersResponse(rsp)
}

// DeleteSessionLaunchersLauncherIdWithResponse request returning *DeleteSessionLaunchersLauncherIdResponse
func (c *ClientWithResponses) DeleteSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*DeleteSessionLaunchersLauncherIdResponse, error) {
	rsp, err := c.DeleteSessionLaunchersLauncherId(ctx, launcherId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSessionLaunchersLauncherIdResponse(rsp)
}

// GetSessionLaunchersLauncherIdWithResponse request returning *GetSessionLaunchersLauncherIdResponse
func (c *ClientWithResponses) GetSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*GetSessionLaunchersLauncherIdResponse, error) {
	rsp, err := c.GetSessionLaunchersLauncherId(ctx, launcherId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionLaunchersLauncherIdResponse(rsp)
}

// PatchSessionLaunchersLauncherIdWithBodyWithResponse request with arbitrary body returning *PatchSessionLaunchersLauncherIdResponse
func (c *ClientWithResponses) PatchSessionLaunchersLauncherIdWithBodyWithResponse(ctx context.Context, launcherId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSessionLaunchersLauncherIdResponse, error) {
	rsp, err := c.PatchSessionLaunchersLauncherIdWithBody(ctx, launcherId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSessionLaunchersLauncherIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSessionLaunchersLauncherIdResponse, error) {
	rsp, err := c.PatchSessionLaunchersLauncherId(ctx, launcherId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSessionLaunchersLauncherIdResponse(rsp)
}

// ParseGetBuildsBuildIdResponse parses an HTTP response from a GetBuildsBuildIdWithResponse call
func ParseGetBuildsBuildIdResponse(rsp *http.Response) (*GetBuildsBuildIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildsBuildIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchBuildsBuildIdResponse parses an HTTP response from a PatchBuildsBuildIdWithResponse call
func ParsePatchBuildsBuildIdResponse(rsp *http.Response) (*PatchBuildsBuildIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchBuildsBuildIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBuildsBuildIdLogsResponse parses an HTTP response from a GetBuildsBuildIdLogsWithResponse call
func ParseGetBuildsBuildIdLogsResponse(rsp *http.Response) (*GetBuildsBuildIdLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildsBuildIdLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildLogs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentsResponse parses an HTTP response from a GetEnvironmentsWithResponse call
func ParseGetEnvironmentsResponse(rsp *http.Response) (*GetEnvironmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnvironmentList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEnvironmentsResponse parses an HTTP response from a PostEnvironmentsWithResponse call
func ParsePostEnvironmentsResponse(rsp *http.Response) (*PostEnvironmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEnvironmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEnvironmentsEnvironmentIdResponse parses an HTTP response from a DeleteEnvironmentsEnvironmentIdWithResponse call
func ParseDeleteEnvironmentsEnvironmentIdResponse(rsp *http.Response) (*DeleteEnvironmentsEnvironmentIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvironmentsEnvironmentIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentsEnvironmentIdResponse parses an HTTP response from a GetEnvironmentsEnvironmentIdWithResponse call
func ParseGetEnvironmentsEnvironmentIdResponse(rsp *http.Response) (*GetEnvironmentsEnvironmentIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentsEnvironmentIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchEnvironmentsEnvironmentIdResponse parses an HTTP response from a PatchEnvironmentsEnvironmentIdWithResponse call
func ParsePatchEnvironmentsEnvironmentIdResponse(rsp *http.Response) (*PatchEnvironmentsEnvironmentIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchEnvironmentsEnvironmentIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentsEnvironmentIdBuildsResponse parses an HTTP response from a GetEnvironmentsEnvironmentIdBuildsWithResponse call
func ParseGetEnvironmentsEnvironmentIdBuildsResponse(rsp *http.Response) (*GetEnvironmentsEnvironmentIdBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentsEnvironmentIdBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEnvironmentsEnvironmentIdBuildsResponse parses an HTTP response from a PostEnvironmentsEnvironmentIdBuildsWithResponse call
func ParsePostEnvironmentsEnvironmentIdBuildsResponse(rsp *http.Response) (*PostEnvironmentsEnvironmentIdBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEnvironmentsEnvironmentIdBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectsProjectIdSessionLaunchersResponse parses an HTTP response from a GetProjectsProjectIdSessionLaunchersWithResponse call
func ParseGetProjectsProjectIdSessionLaunchersResponse(rsp *http.Response) (*GetProjectsProjectIdSessionLaunchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsProjectIdSessionLaunchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLaunchersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSessionLaunchersResponse parses an HTTP response from a GetSessionLaunchersWithResponse call
func ParseGetSessionLaunchersResponse(rsp *http.Response) (*GetSessionLaunchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionLaunchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLaunchersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSessionLaunchersResponse parses an HTTP response from a PostSessionLaunchersWithResponse call
func ParsePostSessionLaunchersResponse(rsp *http.Response) (*PostSessionLaunchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSessionLaunchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionLauncher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSessionLaunchersLauncherIdResponse parses an HTTP response from a DeleteSessionLaunchersLauncherIdWithResponse call
func ParseDeleteSessionLaunchersLauncherIdResponse(rsp *http.Response) (*DeleteSessionLaunchersLauncherIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSessionLaunchersLauncherIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSessionLaunchersLauncherIdResponse parses an HTTP response from a GetSessionLaunchersLauncherIdWithResponse call
func ParseGetSessionLaunchersLauncherIdResponse(rsp *http.Response) (*GetSessionLaunchersLauncherIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionLaunchersLauncherIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLauncher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchSessionLaunchersLauncherIdResponse parses an HTTP response from a PatchSessionLaunchersLauncherIdWithResponse call
func ParsePatchSessionLaunchersLauncherIdResponse(rsp *http.Response) (*PatchSessionLaunchersLauncherIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSessionLaunchersLauncherIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLauncher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
