// Package session provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package session

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for BuildCompletedPartStatus.
const (
	Succeeded BuildCompletedPartStatus = "succeeded"
)

// Defines values for BuildNotCompletedPartStatus.
const (
	BuildNotCompletedPartStatusCancelled  BuildNotCompletedPartStatus = "cancelled"
	BuildNotCompletedPartStatusFailed     BuildNotCompletedPartStatus = "failed"
	BuildNotCompletedPartStatusInProgress BuildNotCompletedPartStatus = "in_progress"
)

// Defines values for BuildPatchStatus.
const (
	BuildPatchStatusCancelled BuildPatchStatus = "cancelled"
)

// Defines values for BuildPlatform.
const (
	Linuxamd64 BuildPlatform = "linux/amd64"
	Linuxarm64 BuildPlatform = "linux/arm64"
)

// Defines values for EnvironmentImageSourceBuild.
const (
	EnvironmentImageSourceBuildBuild EnvironmentImageSourceBuild = "build"
)

// Defines values for EnvironmentImageSourceImage.
const (
	Image EnvironmentImageSourceImage = "image"
)

// Defines values for EnvironmentKind.
const (
	CUSTOM EnvironmentKind = "CUSTOM"
	GLOBAL EnvironmentKind = "GLOBAL"
)

// Build defines model for Build.
type Build struct {
	// CreatedAt The date and time the resource was created (in UTC and ISO-8601 format)
	CreatedAt CreationDate `json:"created_at"`

	// EnvironmentId ULID identifier
	EnvironmentId Ulid `json:"environment_id"`

	// ErrorReason The reason why a container image build did not succeed, if available.
	ErrorReason *ErrorReason `json:"error_reason,omitempty"`

	// Id ULID identifier
	Id    Ulid `json:"id"`
	union json.RawMessage
}

// BuildCommonPart defines model for BuildCommonPart.
type BuildCommonPart struct {
	// CreatedAt The date and time the resource was created (in UTC and ISO-8601 format)
	CreatedAt CreationDate `json:"created_at"`

	// EnvironmentId ULID identifier
	EnvironmentId Ulid `json:"environment_id"`

	// ErrorReason The reason why a container image build did not succeed, if available.
	ErrorReason *ErrorReason `json:"error_reason,omitempty"`

	// Id ULID identifier
	Id Ulid `json:"id"`
}

// BuildCompletedPart defines model for BuildCompletedPart.
type BuildCompletedPart struct {
	// Result The result of a container image build
	Result BuildResult              `json:"result"`
	Status BuildCompletedPartStatus `json:"status"`
}

// BuildCompletedPartStatus defines model for BuildCompletedPart.Status.
type BuildCompletedPartStatus string

// BuildContextDir The relative path to a folder
type BuildContextDir = string

// BuildContextDirPatch The relative path to a folder
type BuildContextDirPatch = string

// BuildList A list of container image builds
type BuildList = []Build

// BuildLogs The logs of a container image build
type BuildLogs map[string]string

// BuildNotCompletedPart defines model for BuildNotCompletedPart.
type BuildNotCompletedPart struct {
	Status BuildNotCompletedPartStatus `json:"status"`
}

// BuildNotCompletedPartStatus defines model for BuildNotCompletedPart.Status.
type BuildNotCompletedPartStatus string

// BuildParameters Build parameters
type BuildParameters struct {
	// BuilderVariant Type of virtual environment manager when building custom environments.
	BuilderVariant BuilderVariant `json:"builder_variant"`

	// ContextDir The relative path to a folder
	ContextDir *BuildContextDir `json:"context_dir,omitempty"`

	// FrontendVariant User's Frontend Choice.
	FrontendVariant FrontendVariant `json:"frontend_variant"`

	// Platforms The target runtime platforms of a session environment.
	Platforms *BuildPlatforms `json:"platforms,omitempty"`

	// Repository A git repository URL
	Repository Repository `json:"repository"`

	// RepositoryRevision A git revision
	RepositoryRevision *RepositoryRevision `json:"repository_revision,omitempty"`
}

// BuildParametersPatch Data for updating a build
type BuildParametersPatch struct {
	// BuilderVariant Type of virtual environment manager when building custom environments.
	BuilderVariant *BuilderVariant `json:"builder_variant,omitempty"`

	// ContextDir The relative path to a folder
	ContextDir *BuildContextDirPatch `json:"context_dir,omitempty"`

	// FrontendVariant User's Frontend Choice.
	FrontendVariant *FrontendVariant `json:"frontend_variant,omitempty"`

	// Platforms The target runtime platforms of a session environment.
	Platforms *BuildPlatforms `json:"platforms,omitempty"`

	// Repository A git repository URL
	Repository *Repository `json:"repository,omitempty"`

	// RepositoryRevision A git revision
	RepositoryRevision *RepositoryRevisionPatch `json:"repository_revision,omitempty"`
}

// BuildParametersPost defines model for BuildParametersPost.
type BuildParametersPost struct {
	// BuilderVariant Type of virtual environment manager when building custom environments.
	BuilderVariant BuilderVariant `json:"builder_variant"`

	// ContextDir The relative path to a folder
	ContextDir             *BuildContextDir            `json:"context_dir,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceBuild `json:"environment_image_source"`

	// FrontendVariant User's Frontend Choice.
	FrontendVariant FrontendVariant `json:"frontend_variant"`

	// Platforms The target runtime platforms of a session environment.
	Platforms *BuildPlatforms `json:"platforms,omitempty"`

	// Repository A git repository URL
	Repository Repository `json:"repository"`

	// RepositoryRevision A git revision
	RepositoryRevision *RepositoryRevision `json:"repository_revision,omitempty"`
}

// BuildPatch The requested update of a container image build
type BuildPatch struct {
	Status *BuildPatchStatus `json:"status,omitempty"`
}

// BuildPatchStatus defines model for BuildPatch.Status.
type BuildPatchStatus string

// BuildPlatform A runtime platform, e.g. "linux/amd64".
type BuildPlatform string

// BuildPlatforms The target runtime platforms of a session environment.
type BuildPlatforms = []BuildPlatform

// BuildResult The result of a container image build
type BuildResult struct {
	// CompletedAt The date and time the resource was created (in UTC and ISO-8601 format)
	CompletedAt CreationDate `json:"completed_at"`

	// Image A container image
	Image                  ContainerImage `json:"image"`
	RepositoryGitCommitSha string         `json:"repository_git_commit_sha"`
	RepositoryUrl          string         `json:"repository_url"`
}

// BuilderVariant Type of virtual environment manager when building custom environments.
type BuilderVariant = string

// ContainerImage A container image
type ContainerImage = string

// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
type CreationDate = time.Time

// DefaultUrl The default path to open in a session
type DefaultUrl = string

// Description A description for the resource
type Description = string

// DiskStorage The size of disk storage for the session, in gigabytes
type DiskStorage = int

// DiskStoragePatch defines model for DiskStoragePatch.
type DiskStoragePatch = int

// EnvVar An environment variable for the session pod
type EnvVar struct {
	Name  string  `json:"name"`
	Value *string `json:"value,omitempty"`
}

// EnvVariables Environment variables for the session pod
type EnvVariables = []EnvVar

// Environment defines model for Environment.
type Environment struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage ContainerImage `json:"container_image"`

	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// DefaultUrl The default path to open in a session
	DefaultUrl DefaultUrl `json:"default_url"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// Gid The group ID used to run the session
	Gid EnvironmentGid `json:"gid"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived *IsArchived `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port            EnvironmentPort  `json:"port"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid EnvironmentUid `json:"uid"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentArgs The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
type EnvironmentArgs = []string

// EnvironmentCommand The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
type EnvironmentCommand = []string

// EnvironmentGetInLauncher defines model for EnvironmentGetInLauncher.
type EnvironmentGetInLauncher struct {
	union json.RawMessage
}

// EnvironmentGid The group ID used to run the session
type EnvironmentGid = int

// EnvironmentId Id of the environment to use
type EnvironmentId = string

// EnvironmentIdOnlyPatch defines model for EnvironmentIdOnlyPatch.
type EnvironmentIdOnlyPatch struct {
	// Id Id of the environment to use
	Id *EnvironmentId `json:"id,omitempty"`
}

// EnvironmentIdOnlyPost defines model for EnvironmentIdOnlyPost.
type EnvironmentIdOnlyPost struct {
	// Id Id of the environment to use
	Id EnvironmentId `json:"id"`
}

// EnvironmentImageSource Source of the environment's image
type EnvironmentImageSource struct {
	union json.RawMessage
}

// EnvironmentImageSourceBuild defines model for EnvironmentImageSourceBuild.
type EnvironmentImageSourceBuild string

// EnvironmentImageSourceImage defines model for EnvironmentImageSourceImage.
type EnvironmentImageSourceImage string

// EnvironmentKind Kind of the environment
type EnvironmentKind string

// EnvironmentList A list of session environments
type EnvironmentList = []Environment

// EnvironmentMountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
type EnvironmentMountDirectory = string

// EnvironmentMountDirectoryPatch defines model for EnvironmentMountDirectoryPatch.
type EnvironmentMountDirectoryPatch = string

// EnvironmentPatch Update a session environment
type EnvironmentPatch struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentPatchArgs `json:"args"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentPatchCommand `json:"command"`

	// ContainerImage A container image
	ContainerImage *ContainerImage `json:"container_image,omitempty"`

	// DefaultUrl The default path to open in a session
	DefaultUrl *DefaultUrl `json:"default_url,omitempty"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// Gid The group ID used to run the session
	Gid *EnvironmentGid `json:"gid,omitempty"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived     *IsArchivedPatch                `json:"is_archived,omitempty"`
	MountDirectory *EnvironmentMountDirectoryPatch `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name *SessionName `json:"name,omitempty"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port *EnvironmentPort `json:"port,omitempty"`

	// StripPathPrefix If set to true the default url and the base path where sessions are
	// served will be removed from all URL paths before the requests reach
	// the server running in the session. So the server in the session will
	// receive HTTP requests whose base path will be "/". However this will
	// not work unless the server running inside the session can be made
	// aware that paths are rewritten. For example, if the application/server
	// running in the session serves a HTML page that then loads javascript
	// and CSS, the path where these assets should be loaded from in the browser
	// will not be "/" but it has to include the prefix that was stripped. And
	// the server from the session that generated the HTML page needs to know
	// what is the full base path (including the part that was stripped) so that
	// it can make the URLs to such assets be reachable from the browser.
	StripPathPrefix *StripPathPrefixPatch `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid              *EnvironmentUid                   `json:"uid,omitempty"`
	WorkingDirectory *EnvironmentWorkingDirectoryPatch `json:"working_directory,omitempty"`
}

// EnvironmentPatchArgs The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
type EnvironmentPatchArgs = []string

// EnvironmentPatchCommand The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
type EnvironmentPatchCommand = []string

// EnvironmentPatchInLauncher defines model for EnvironmentPatchInLauncher.
type EnvironmentPatchInLauncher struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentPatchArgs `json:"args"`

	// BuildParameters Data for updating a build
	BuildParameters *BuildParametersPatch `json:"build_parameters,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentPatchCommand `json:"command"`

	// ContainerImage A container image
	ContainerImage *ContainerImage `json:"container_image,omitempty"`

	// DefaultUrl The default path to open in a session
	DefaultUrl *DefaultUrl `json:"default_url,omitempty"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// EnvironmentImageSource Source of the environment's image
	EnvironmentImageSource *EnvironmentImageSource `json:"environment_image_source,omitempty"`

	// EnvironmentKind Kind of the environment
	EnvironmentKind *EnvironmentKind `json:"environment_kind,omitempty"`

	// Gid The group ID used to run the session
	Gid *EnvironmentGid `json:"gid,omitempty"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived     *IsArchivedPatch                `json:"is_archived,omitempty"`
	MountDirectory *EnvironmentMountDirectoryPatch `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name *SessionName `json:"name,omitempty"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port *EnvironmentPort `json:"port,omitempty"`

	// StripPathPrefix If set to true the default url and the base path where sessions are
	// served will be removed from all URL paths before the requests reach
	// the server running in the session. So the server in the session will
	// receive HTTP requests whose base path will be "/". However this will
	// not work unless the server running inside the session can be made
	// aware that paths are rewritten. For example, if the application/server
	// running in the session serves a HTML page that then loads javascript
	// and CSS, the path where these assets should be loaded from in the browser
	// will not be "/" but it has to include the prefix that was stripped. And
	// the server from the session that generated the HTML page needs to know
	// what is the full base path (including the part that was stripped) so that
	// it can make the URLs to such assets be reachable from the browser.
	StripPathPrefix *StripPathPrefixPatch `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid              *EnvironmentUid                   `json:"uid,omitempty"`
	WorkingDirectory *EnvironmentWorkingDirectoryPatch `json:"working_directory,omitempty"`
}

// EnvironmentPort The TCP port (on any container in the session) where user requests will be routed to from the ingress
type EnvironmentPort = int

// EnvironmentPost Data required to create a session environment
type EnvironmentPost struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage ContainerImage `json:"container_image"`
	DefaultUrl     *DefaultUrl    `json:"default_url,omitempty"`

	// Description A description for the resource
	Description            *Description                `json:"description,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceImage `json:"environment_image_source"`
	Gid                    *EnvironmentGid             `json:"gid,omitempty"`
	IsArchived             *IsArchived                 `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name            SessionName      `json:"name"`
	Port            *EnvironmentPort `json:"port,omitempty"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`
	Uid             *EnvironmentUid  `json:"uid,omitempty"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentPostInLauncher defines model for EnvironmentPostInLauncher.
type EnvironmentPostInLauncher struct {
	union json.RawMessage
}

// EnvironmentPostInLauncherHelper defines model for EnvironmentPostInLauncherHelper.
type EnvironmentPostInLauncherHelper struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage ContainerImage `json:"container_image"`
	DefaultUrl     *DefaultUrl    `json:"default_url,omitempty"`

	// Description A description for the resource
	Description            *Description                `json:"description,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceImage `json:"environment_image_source"`

	// EnvironmentKind Kind of the environment
	EnvironmentKind EnvironmentKind `json:"environment_kind"`
	Gid             *EnvironmentGid `json:"gid,omitempty"`
	IsArchived      *IsArchived     `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name            SessionName      `json:"name"`
	Port            *EnvironmentPort `json:"port,omitempty"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`
	Uid             *EnvironmentUid  `json:"uid,omitempty"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentUid The user ID used to run the session
type EnvironmentUid = int

// EnvironmentWithBuildGet defines model for EnvironmentWithBuildGet.
type EnvironmentWithBuildGet struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// BuildParameters Build parameters
	BuildParameters BuildParameters `json:"build_parameters"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage *ContainerImage `json:"container_image,omitempty"`

	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// DefaultUrl The default path to open in a session
	DefaultUrl DefaultUrl `json:"default_url"`

	// Description A description for the resource
	Description            *Description                `json:"description,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceBuild `json:"environment_image_source"`
	EnvironmentKind        EnvironmentKind             `json:"environment_kind"`

	// Gid The group ID used to run the session
	Gid EnvironmentGid `json:"gid"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived *IsArchived `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port            EnvironmentPort  `json:"port"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid EnvironmentUid `json:"uid"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentWithImageGet defines model for EnvironmentWithImageGet.
type EnvironmentWithImageGet struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// ContainerImage A container image
	ContainerImage ContainerImage `json:"container_image"`

	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// DefaultUrl The default path to open in a session
	DefaultUrl DefaultUrl `json:"default_url"`

	// Description A description for the resource
	Description            *Description                `json:"description,omitempty"`
	EnvironmentImageSource EnvironmentImageSourceImage `json:"environment_image_source"`
	EnvironmentKind        EnvironmentKind             `json:"environment_kind"`

	// Gid The group ID used to run the session
	Gid EnvironmentGid `json:"gid"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived *IsArchived `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port            EnvironmentPort  `json:"port"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid EnvironmentUid `json:"uid"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentWithoutContainerImage A Renku 2.0 session environment
type EnvironmentWithoutContainerImage struct {
	// Args The arguments that will follow the command, i.e. will overwrite the image Dockerfile CMD, equivalent to args in Kubernetes
	Args *EnvironmentArgs `json:"args,omitempty"`

	// Command The command that will be run i.e. will overwrite the image Dockerfile ENTRYPOINT, equivalent to command in Kubernetes
	Command *EnvironmentCommand `json:"command,omitempty"`

	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// DefaultUrl The default path to open in a session
	DefaultUrl DefaultUrl `json:"default_url"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// Gid The group ID used to run the session
	Gid EnvironmentGid `json:"gid"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// IsArchived Whether this environment is archived and not for use in new projects or not
	IsArchived *IsArchived `json:"is_archived,omitempty"`

	// MountDirectory The location where the persistent storage for the session will be mounted, usually it should be identical to or a parent of the working directory, if left unset will default to the working directory.
	MountDirectory *EnvironmentMountDirectory `json:"mount_directory,omitempty"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// Port The TCP port (on any container in the session) where user requests will be routed to from the ingress
	Port            EnvironmentPort  `json:"port"`
	StripPathPrefix *StripPathPrefix `json:"strip_path_prefix,omitempty"`

	// Uid The user ID used to run the session
	Uid EnvironmentUid `json:"uid"`

	// WorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
	WorkingDirectory *EnvironmentWorkingDirectory `json:"working_directory,omitempty"`
}

// EnvironmentWorkingDirectory The location where the session will start, if left unset it will default to the session image working directory.
type EnvironmentWorkingDirectory = string

// EnvironmentWorkingDirectoryPatch defines model for EnvironmentWorkingDirectoryPatch.
type EnvironmentWorkingDirectoryPatch = string

// ErrorReason The reason why a container image build did not succeed, if available.
type ErrorReason = string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error struct {
		Code    int     `json:"code"`
		Detail  *string `json:"detail,omitempty"`
		Message string  `json:"message"`
	} `json:"error"`
}

// FrontendVariant User's Frontend Choice.
type FrontendVariant = string

// IsArchived Whether this environment is archived and not for use in new projects or not
type IsArchived = bool

// IsArchivedPatch Whether this environment is archived and not for use in new projects or not
type IsArchivedPatch = bool

// Repository A git repository URL
type Repository = string

// RepositoryRevision A git revision
type RepositoryRevision = string

// RepositoryRevisionPatch A git revision
type RepositoryRevisionPatch = string

// ResourceClassId The identifier of a resource class
type ResourceClassId = int

// SessionLauncher A Renku 2.0 session definition and metadata
type SessionLauncher struct {
	// CreationDate The date and time the resource was created (in UTC and ISO-8601 format)
	CreationDate CreationDate `json:"creation_date"`

	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// DiskStorage The size of disk storage for the session, in gigabytes
	DiskStorage *DiskStorage `json:"disk_storage,omitempty"`

	// EnvVariables Environment variables for the session pod
	EnvVariables *EnvVariables            `json:"env_variables,omitempty"`
	Environment  EnvironmentGetInLauncher `json:"environment"`

	// Id ULID identifier
	Id Ulid `json:"id"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// ProjectId ULID identifier
	ProjectId Ulid `json:"project_id"`

	// ResourceClassId The identifier of a resource class
	ResourceClassId *ResourceClassId `json:"resource_class_id"`
}

// SessionLauncherPatch Update a session launcher
type SessionLauncherPatch struct {
	// Description A description for the resource
	Description *Description      `json:"description,omitempty"`
	DiskStorage *DiskStoragePatch `json:"disk_storage"`

	// EnvVariables Environment variables for the session pod
	EnvVariables *EnvVariables                     `json:"env_variables,omitempty"`
	Environment  *SessionLauncherPatch_Environment `json:"environment,omitempty"`

	// Name Renku session name
	Name *SessionName `json:"name,omitempty"`

	// ResourceClassId The identifier of a resource class
	ResourceClassId *ResourceClassId `json:"resource_class_id"`
}

// SessionLauncherPatch_Environment defines model for SessionLauncherPatch.Environment.
type SessionLauncherPatch_Environment struct {
	union json.RawMessage
}

// SessionLauncherPost Data required to create a session launcher
type SessionLauncherPost struct {
	// Description A description for the resource
	Description *Description `json:"description,omitempty"`

	// DiskStorage The size of disk storage for the session, in gigabytes
	DiskStorage *DiskStorage `json:"disk_storage,omitempty"`

	// EnvVariables Environment variables for the session pod
	EnvVariables *EnvVariables                   `json:"env_variables,omitempty"`
	Environment  SessionLauncherPost_Environment `json:"environment"`

	// Name Renku session name
	Name SessionName `json:"name"`

	// ProjectId ULID identifier
	ProjectId Ulid `json:"project_id"`

	// ResourceClassId The identifier of a resource class
	ResourceClassId *ResourceClassId `json:"resource_class_id"`
}

// SessionLauncherPost_Environment defines model for SessionLauncherPost.Environment.
type SessionLauncherPost_Environment struct {
	union json.RawMessage
}

// SessionLaunchersList A list of Renku session launchers
type SessionLaunchersList = []SessionLauncher

// SessionName Renku session name
type SessionName = string

// StripPathPrefix If set to true the default url and the base path where sessions are
// served will be removed from all URL paths before the requests reach
// the server running in the session. So the server in the session will
// receive HTTP requests whose base path will be "/". However this will
// not work unless the server running inside the session can be made
// aware that paths are rewritten. For example, if the application/server
// running in the session serves a HTML page that then loads javascript
// and CSS, the path where these assets should be loaded from in the browser
// will not be "/" but it has to include the prefix that was stripped. And
// the server from the session that generated the HTML page needs to know
// what is the full base path (including the part that was stripped) so that
// it can make the URLs to such assets be reachable from the browser.
type StripPathPrefix = bool

// StripPathPrefixPatch If set to true the default url and the base path where sessions are
// served will be removed from all URL paths before the requests reach
// the server running in the session. So the server in the session will
// receive HTTP requests whose base path will be "/". However this will
// not work unless the server running inside the session can be made
// aware that paths are rewritten. For example, if the application/server
// running in the session serves a HTML page that then loads javascript
// and CSS, the path where these assets should be loaded from in the browser
// will not be "/" but it has to include the prefix that was stripped. And
// the server from the session that generated the HTML page needs to know
// what is the full base path (including the part that was stripped) so that
// it can make the URLs to such assets be reachable from the browser.
type StripPathPrefixPatch = bool

// Ulid ULID identifier
type Ulid = string

// Error defines model for Error.
type Error = ErrorResponse

// GetBuildsBuildIdLogsParams defines parameters for GetBuildsBuildIdLogs.
type GetBuildsBuildIdLogsParams struct {
	// MaxLines The maximum number of most-recent lines to return for each container
	MaxLines *int `form:"max_lines,omitempty" json:"max_lines,omitempty"`
}

// GetEnvironmentsParams defines parameters for GetEnvironments.
type GetEnvironmentsParams struct {
	GetEnvironmentParams *struct {
		// IncludeArchived Whether to return archived environments or not
		IncludeArchived *bool `json:"include_archived,omitempty"`
	} `form:"get_environment_params,omitempty" json:"get_environment_params,omitempty"`
}

// PatchBuildsBuildIdJSONRequestBody defines body for PatchBuildsBuildId for application/json ContentType.
type PatchBuildsBuildIdJSONRequestBody = BuildPatch

// PostEnvironmentsJSONRequestBody defines body for PostEnvironments for application/json ContentType.
type PostEnvironmentsJSONRequestBody = EnvironmentPost

// PatchEnvironmentsEnvironmentIdJSONRequestBody defines body for PatchEnvironmentsEnvironmentId for application/json ContentType.
type PatchEnvironmentsEnvironmentIdJSONRequestBody = EnvironmentPatch

// PostSessionLaunchersJSONRequestBody defines body for PostSessionLaunchers for application/json ContentType.
type PostSessionLaunchersJSONRequestBody = SessionLauncherPost

// PatchSessionLaunchersLauncherIdJSONRequestBody defines body for PatchSessionLaunchersLauncherId for application/json ContentType.
type PatchSessionLaunchersLauncherIdJSONRequestBody = SessionLauncherPatch

// AsBuildNotCompletedPart returns the union data inside the Build as a BuildNotCompletedPart
func (t Build) AsBuildNotCompletedPart() (BuildNotCompletedPart, error) {
	var body BuildNotCompletedPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBuildNotCompletedPart overwrites any union data inside the Build as the provided BuildNotCompletedPart
func (t *Build) FromBuildNotCompletedPart(v BuildNotCompletedPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBuildNotCompletedPart performs a merge with any union data inside the Build, using the provided BuildNotCompletedPart
func (t *Build) MergeBuildNotCompletedPart(v BuildNotCompletedPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBuildCompletedPart returns the union data inside the Build as a BuildCompletedPart
func (t Build) AsBuildCompletedPart() (BuildCompletedPart, error) {
	var body BuildCompletedPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBuildCompletedPart overwrites any union data inside the Build as the provided BuildCompletedPart
func (t *Build) FromBuildCompletedPart(v BuildCompletedPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBuildCompletedPart performs a merge with any union data inside the Build, using the provided BuildCompletedPart
func (t *Build) MergeBuildCompletedPart(v BuildCompletedPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Build) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["created_at"], err = json.Marshal(t.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["environment_id"], err = json.Marshal(t.EnvironmentId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'environment_id': %w", err)
	}

	if t.ErrorReason != nil {
		object["error_reason"], err = json.Marshal(t.ErrorReason)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error_reason': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Build) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
	}

	if raw, found := object["environment_id"]; found {
		err = json.Unmarshal(raw, &t.EnvironmentId)
		if err != nil {
			return fmt.Errorf("error reading 'environment_id': %w", err)
		}
	}

	if raw, found := object["error_reason"]; found {
		err = json.Unmarshal(raw, &t.ErrorReason)
		if err != nil {
			return fmt.Errorf("error reading 'error_reason': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	return err
}

// AsEnvironmentWithImageGet returns the union data inside the EnvironmentGetInLauncher as a EnvironmentWithImageGet
func (t EnvironmentGetInLauncher) AsEnvironmentWithImageGet() (EnvironmentWithImageGet, error) {
	var body EnvironmentWithImageGet
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentWithImageGet overwrites any union data inside the EnvironmentGetInLauncher as the provided EnvironmentWithImageGet
func (t *EnvironmentGetInLauncher) FromEnvironmentWithImageGet(v EnvironmentWithImageGet) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentWithImageGet performs a merge with any union data inside the EnvironmentGetInLauncher, using the provided EnvironmentWithImageGet
func (t *EnvironmentGetInLauncher) MergeEnvironmentWithImageGet(v EnvironmentWithImageGet) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentWithBuildGet returns the union data inside the EnvironmentGetInLauncher as a EnvironmentWithBuildGet
func (t EnvironmentGetInLauncher) AsEnvironmentWithBuildGet() (EnvironmentWithBuildGet, error) {
	var body EnvironmentWithBuildGet
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentWithBuildGet overwrites any union data inside the EnvironmentGetInLauncher as the provided EnvironmentWithBuildGet
func (t *EnvironmentGetInLauncher) FromEnvironmentWithBuildGet(v EnvironmentWithBuildGet) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentWithBuildGet performs a merge with any union data inside the EnvironmentGetInLauncher, using the provided EnvironmentWithBuildGet
func (t *EnvironmentGetInLauncher) MergeEnvironmentWithBuildGet(v EnvironmentWithBuildGet) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentGetInLauncher) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentGetInLauncher) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentImageSourceImage returns the union data inside the EnvironmentImageSource as a EnvironmentImageSourceImage
func (t EnvironmentImageSource) AsEnvironmentImageSourceImage() (EnvironmentImageSourceImage, error) {
	var body EnvironmentImageSourceImage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentImageSourceImage overwrites any union data inside the EnvironmentImageSource as the provided EnvironmentImageSourceImage
func (t *EnvironmentImageSource) FromEnvironmentImageSourceImage(v EnvironmentImageSourceImage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentImageSourceImage performs a merge with any union data inside the EnvironmentImageSource, using the provided EnvironmentImageSourceImage
func (t *EnvironmentImageSource) MergeEnvironmentImageSourceImage(v EnvironmentImageSourceImage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentImageSourceBuild returns the union data inside the EnvironmentImageSource as a EnvironmentImageSourceBuild
func (t EnvironmentImageSource) AsEnvironmentImageSourceBuild() (EnvironmentImageSourceBuild, error) {
	var body EnvironmentImageSourceBuild
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentImageSourceBuild overwrites any union data inside the EnvironmentImageSource as the provided EnvironmentImageSourceBuild
func (t *EnvironmentImageSource) FromEnvironmentImageSourceBuild(v EnvironmentImageSourceBuild) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentImageSourceBuild performs a merge with any union data inside the EnvironmentImageSource, using the provided EnvironmentImageSourceBuild
func (t *EnvironmentImageSource) MergeEnvironmentImageSourceBuild(v EnvironmentImageSourceBuild) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentImageSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentImageSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentPostInLauncherHelper returns the union data inside the EnvironmentPostInLauncher as a EnvironmentPostInLauncherHelper
func (t EnvironmentPostInLauncher) AsEnvironmentPostInLauncherHelper() (EnvironmentPostInLauncherHelper, error) {
	var body EnvironmentPostInLauncherHelper
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentPostInLauncherHelper overwrites any union data inside the EnvironmentPostInLauncher as the provided EnvironmentPostInLauncherHelper
func (t *EnvironmentPostInLauncher) FromEnvironmentPostInLauncherHelper(v EnvironmentPostInLauncherHelper) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentPostInLauncherHelper performs a merge with any union data inside the EnvironmentPostInLauncher, using the provided EnvironmentPostInLauncherHelper
func (t *EnvironmentPostInLauncher) MergeEnvironmentPostInLauncherHelper(v EnvironmentPostInLauncherHelper) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBuildParametersPost returns the union data inside the EnvironmentPostInLauncher as a BuildParametersPost
func (t EnvironmentPostInLauncher) AsBuildParametersPost() (BuildParametersPost, error) {
	var body BuildParametersPost
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBuildParametersPost overwrites any union data inside the EnvironmentPostInLauncher as the provided BuildParametersPost
func (t *EnvironmentPostInLauncher) FromBuildParametersPost(v BuildParametersPost) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBuildParametersPost performs a merge with any union data inside the EnvironmentPostInLauncher, using the provided BuildParametersPost
func (t *EnvironmentPostInLauncher) MergeBuildParametersPost(v BuildParametersPost) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentPostInLauncher) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentPostInLauncher) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentPatchInLauncher returns the union data inside the SessionLauncherPatch_Environment as a EnvironmentPatchInLauncher
func (t SessionLauncherPatch_Environment) AsEnvironmentPatchInLauncher() (EnvironmentPatchInLauncher, error) {
	var body EnvironmentPatchInLauncher
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentPatchInLauncher overwrites any union data inside the SessionLauncherPatch_Environment as the provided EnvironmentPatchInLauncher
func (t *SessionLauncherPatch_Environment) FromEnvironmentPatchInLauncher(v EnvironmentPatchInLauncher) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentPatchInLauncher performs a merge with any union data inside the SessionLauncherPatch_Environment, using the provided EnvironmentPatchInLauncher
func (t *SessionLauncherPatch_Environment) MergeEnvironmentPatchInLauncher(v EnvironmentPatchInLauncher) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentIdOnlyPatch returns the union data inside the SessionLauncherPatch_Environment as a EnvironmentIdOnlyPatch
func (t SessionLauncherPatch_Environment) AsEnvironmentIdOnlyPatch() (EnvironmentIdOnlyPatch, error) {
	var body EnvironmentIdOnlyPatch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentIdOnlyPatch overwrites any union data inside the SessionLauncherPatch_Environment as the provided EnvironmentIdOnlyPatch
func (t *SessionLauncherPatch_Environment) FromEnvironmentIdOnlyPatch(v EnvironmentIdOnlyPatch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentIdOnlyPatch performs a merge with any union data inside the SessionLauncherPatch_Environment, using the provided EnvironmentIdOnlyPatch
func (t *SessionLauncherPatch_Environment) MergeEnvironmentIdOnlyPatch(v EnvironmentIdOnlyPatch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SessionLauncherPatch_Environment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SessionLauncherPatch_Environment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentPostInLauncher returns the union data inside the SessionLauncherPost_Environment as a EnvironmentPostInLauncher
func (t SessionLauncherPost_Environment) AsEnvironmentPostInLauncher() (EnvironmentPostInLauncher, error) {
	var body EnvironmentPostInLauncher
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentPostInLauncher overwrites any union data inside the SessionLauncherPost_Environment as the provided EnvironmentPostInLauncher
func (t *SessionLauncherPost_Environment) FromEnvironmentPostInLauncher(v EnvironmentPostInLauncher) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentPostInLauncher performs a merge with any union data inside the SessionLauncherPost_Environment, using the provided EnvironmentPostInLauncher
func (t *SessionLauncherPost_Environment) MergeEnvironmentPostInLauncher(v EnvironmentPostInLauncher) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentIdOnlyPost returns the union data inside the SessionLauncherPost_Environment as a EnvironmentIdOnlyPost
func (t SessionLauncherPost_Environment) AsEnvironmentIdOnlyPost() (EnvironmentIdOnlyPost, error) {
	var body EnvironmentIdOnlyPost
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentIdOnlyPost overwrites any union data inside the SessionLauncherPost_Environment as the provided EnvironmentIdOnlyPost
func (t *SessionLauncherPost_Environment) FromEnvironmentIdOnlyPost(v EnvironmentIdOnlyPost) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentIdOnlyPost performs a merge with any union data inside the SessionLauncherPost_Environment, using the provided EnvironmentIdOnlyPost
func (t *SessionLauncherPost_Environment) MergeEnvironmentIdOnlyPost(v EnvironmentIdOnlyPost) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SessionLauncherPost_Environment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SessionLauncherPost_Environment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetBuildsBuildId request
	GetBuildsBuildId(ctx context.Context, buildId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchBuildsBuildIdWithBody request with any body
	PatchBuildsBuildIdWithBody(ctx context.Context, buildId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchBuildsBuildId(ctx context.Context, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuildsBuildIdLogs request
	GetBuildsBuildIdLogs(ctx context.Context, buildId Ulid, params *GetBuildsBuildIdLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironments request
	GetEnvironments(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEnvironmentsWithBody request with any body
	PostEnvironmentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEnvironments(ctx context.Context, body PostEnvironmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEnvironmentsEnvironmentId request
	DeleteEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentsEnvironmentId request
	GetEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchEnvironmentsEnvironmentIdWithBody request with any body
	PatchEnvironmentsEnvironmentIdWithBody(ctx context.Context, environmentId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentsEnvironmentIdBuilds request
	GetEnvironmentsEnvironmentIdBuilds(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEnvironmentsEnvironmentIdBuilds request
	PostEnvironmentsEnvironmentIdBuilds(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectsProjectIdSessionLaunchers request
	GetProjectsProjectIdSessionLaunchers(ctx context.Context, projectId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionLaunchers request
	GetSessionLaunchers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSessionLaunchersWithBody request with any body
	PostSessionLaunchersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSessionLaunchers(ctx context.Context, body PostSessionLaunchersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSessionLaunchersLauncherId request
	DeleteSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionLaunchersLauncherId request
	GetSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSessionLaunchersLauncherIdWithBody request with any body
	PatchSessionLaunchersLauncherIdWithBody(ctx context.Context, launcherId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetBuildsBuildId(ctx context.Context, buildId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildsBuildIdRequest(c.Server, buildId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBuildsBuildIdWithBody(ctx context.Context, buildId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBuildsBuildIdRequestWithBody(c.Server, buildId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBuildsBuildId(ctx context.Context, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBuildsBuildIdRequest(c.Server, buildId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuildsBuildIdLogs(ctx context.Context, buildId Ulid, params *GetBuildsBuildIdLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildsBuildIdLogsRequest(c.Server, buildId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironments(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEnvironmentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEnvironmentsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEnvironments(ctx context.Context, body PostEnvironmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEnvironmentsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEnvironmentsEnvironmentIdRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentsEnvironmentIdRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEnvironmentsEnvironmentIdWithBody(ctx context.Context, environmentId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEnvironmentsEnvironmentIdRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEnvironmentsEnvironmentId(ctx context.Context, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEnvironmentsEnvironmentIdRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentsEnvironmentIdBuilds(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentsEnvironmentIdBuildsRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEnvironmentsEnvironmentIdBuilds(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEnvironmentsEnvironmentIdBuildsRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsProjectIdSessionLaunchers(ctx context.Context, projectId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectsProjectIdSessionLaunchersRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionLaunchers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionLaunchersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSessionLaunchersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSessionLaunchersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSessionLaunchers(ctx context.Context, body PostSessionLaunchersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSessionLaunchersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSessionLaunchersLauncherIdRequest(c.Server, launcherId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionLaunchersLauncherIdRequest(c.Server, launcherId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSessionLaunchersLauncherIdWithBody(ctx context.Context, launcherId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSessionLaunchersLauncherIdRequestWithBody(c.Server, launcherId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSessionLaunchersLauncherId(ctx context.Context, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSessionLaunchersLauncherIdRequest(c.Server, launcherId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetBuildsBuildIdRequest generates requests for GetBuildsBuildId
func NewGetBuildsBuildIdRequest(server string, buildId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/builds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchBuildsBuildIdRequest calls the generic PatchBuildsBuildId builder with application/json body
func NewPatchBuildsBuildIdRequest(server string, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchBuildsBuildIdRequestWithBody(server, buildId, "application/json", bodyReader)
}

// NewPatchBuildsBuildIdRequestWithBody generates requests for PatchBuildsBuildId with any type of body
func NewPatchBuildsBuildIdRequestWithBody(server string, buildId Ulid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/builds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBuildsBuildIdLogsRequest generates requests for GetBuildsBuildIdLogs
func NewGetBuildsBuildIdLogsRequest(server string, buildId Ulid, params *GetBuildsBuildIdLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/builds/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_lines", runtime.ParamLocationQuery, *params.MaxLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvironmentsRequest generates requests for GetEnvironments
func NewGetEnvironmentsRequest(server string, params *GetEnvironmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GetEnvironmentParams != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "get_environment_params", runtime.ParamLocationQuery, *params.GetEnvironmentParams); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEnvironmentsRequest calls the generic PostEnvironments builder with application/json body
func NewPostEnvironmentsRequest(server string, body PostEnvironmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEnvironmentsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEnvironmentsRequestWithBody generates requests for PostEnvironments with any type of body
func NewPostEnvironmentsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEnvironmentsEnvironmentIdRequest generates requests for DeleteEnvironmentsEnvironmentId
func NewDeleteEnvironmentsEnvironmentIdRequest(server string, environmentId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvironmentsEnvironmentIdRequest generates requests for GetEnvironmentsEnvironmentId
func NewGetEnvironmentsEnvironmentIdRequest(server string, environmentId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchEnvironmentsEnvironmentIdRequest calls the generic PatchEnvironmentsEnvironmentId builder with application/json body
func NewPatchEnvironmentsEnvironmentIdRequest(server string, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchEnvironmentsEnvironmentIdRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewPatchEnvironmentsEnvironmentIdRequestWithBody generates requests for PatchEnvironmentsEnvironmentId with any type of body
func NewPatchEnvironmentsEnvironmentIdRequestWithBody(server string, environmentId Ulid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnvironmentsEnvironmentIdBuildsRequest generates requests for GetEnvironmentsEnvironmentIdBuilds
func NewGetEnvironmentsEnvironmentIdBuildsRequest(server string, environmentId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEnvironmentsEnvironmentIdBuildsRequest generates requests for PostEnvironmentsEnvironmentIdBuilds
func NewPostEnvironmentsEnvironmentIdBuildsRequest(server string, environmentId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/environments/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectsProjectIdSessionLaunchersRequest generates requests for GetProjectsProjectIdSessionLaunchers
func NewGetProjectsProjectIdSessionLaunchersRequest(server string, projectId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/session_launchers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSessionLaunchersRequest generates requests for GetSessionLaunchers
func NewGetSessionLaunchersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSessionLaunchersRequest calls the generic PostSessionLaunchers builder with application/json body
func NewPostSessionLaunchersRequest(server string, body PostSessionLaunchersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSessionLaunchersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSessionLaunchersRequestWithBody generates requests for PostSessionLaunchers with any type of body
func NewPostSessionLaunchersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSessionLaunchersLauncherIdRequest generates requests for DeleteSessionLaunchersLauncherId
func NewDeleteSessionLaunchersLauncherIdRequest(server string, launcherId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "launcher_id", runtime.ParamLocationPath, launcherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSessionLaunchersLauncherIdRequest generates requests for GetSessionLaunchersLauncherId
func NewGetSessionLaunchersLauncherIdRequest(server string, launcherId Ulid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "launcher_id", runtime.ParamLocationPath, launcherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSessionLaunchersLauncherIdRequest calls the generic PatchSessionLaunchersLauncherId builder with application/json body
func NewPatchSessionLaunchersLauncherIdRequest(server string, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSessionLaunchersLauncherIdRequestWithBody(server, launcherId, "application/json", bodyReader)
}

// NewPatchSessionLaunchersLauncherIdRequestWithBody generates requests for PatchSessionLaunchersLauncherId with any type of body
func NewPatchSessionLaunchersLauncherIdRequestWithBody(server string, launcherId Ulid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "launcher_id", runtime.ParamLocationPath, launcherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session_launchers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetBuildsBuildIdWithResponse request
	GetBuildsBuildIdWithResponse(ctx context.Context, buildId Ulid, reqEditors ...RequestEditorFn) (*GetBuildsBuildIdResponse, error)

	// PatchBuildsBuildIdWithBodyWithResponse request with any body
	PatchBuildsBuildIdWithBodyWithResponse(ctx context.Context, buildId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBuildsBuildIdResponse, error)

	PatchBuildsBuildIdWithResponse(ctx context.Context, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBuildsBuildIdResponse, error)

	// GetBuildsBuildIdLogsWithResponse request
	GetBuildsBuildIdLogsWithResponse(ctx context.Context, buildId Ulid, params *GetBuildsBuildIdLogsParams, reqEditors ...RequestEditorFn) (*GetBuildsBuildIdLogsResponse, error)

	// GetEnvironmentsWithResponse request
	GetEnvironmentsWithResponse(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*GetEnvironmentsResponse, error)

	// PostEnvironmentsWithBodyWithResponse request with any body
	PostEnvironmentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEnvironmentsResponse, error)

	PostEnvironmentsWithResponse(ctx context.Context, body PostEnvironmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEnvironmentsResponse, error)

	// DeleteEnvironmentsEnvironmentIdWithResponse request
	DeleteEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*DeleteEnvironmentsEnvironmentIdResponse, error)

	// GetEnvironmentsEnvironmentIdWithResponse request
	GetEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*GetEnvironmentsEnvironmentIdResponse, error)

	// PatchEnvironmentsEnvironmentIdWithBodyWithResponse request with any body
	PatchEnvironmentsEnvironmentIdWithBodyWithResponse(ctx context.Context, environmentId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEnvironmentsEnvironmentIdResponse, error)

	PatchEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEnvironmentsEnvironmentIdResponse, error)

	// GetEnvironmentsEnvironmentIdBuildsWithResponse request
	GetEnvironmentsEnvironmentIdBuildsWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*GetEnvironmentsEnvironmentIdBuildsResponse, error)

	// PostEnvironmentsEnvironmentIdBuildsWithResponse request
	PostEnvironmentsEnvironmentIdBuildsWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*PostEnvironmentsEnvironmentIdBuildsResponse, error)

	// GetProjectsProjectIdSessionLaunchersWithResponse request
	GetProjectsProjectIdSessionLaunchersWithResponse(ctx context.Context, projectId Ulid, reqEditors ...RequestEditorFn) (*GetProjectsProjectIdSessionLaunchersResponse, error)

	// GetSessionLaunchersWithResponse request
	GetSessionLaunchersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionLaunchersResponse, error)

	// PostSessionLaunchersWithBodyWithResponse request with any body
	PostSessionLaunchersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSessionLaunchersResponse, error)

	PostSessionLaunchersWithResponse(ctx context.Context, body PostSessionLaunchersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSessionLaunchersResponse, error)

	// DeleteSessionLaunchersLauncherIdWithResponse request
	DeleteSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*DeleteSessionLaunchersLauncherIdResponse, error)

	// GetSessionLaunchersLauncherIdWithResponse request
	GetSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*GetSessionLaunchersLauncherIdResponse, error)

	// PatchSessionLaunchersLauncherIdWithBodyWithResponse request with any body
	PatchSessionLaunchersLauncherIdWithBodyWithResponse(ctx context.Context, launcherId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSessionLaunchersLauncherIdResponse, error)

	PatchSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSessionLaunchersLauncherIdResponse, error)
}

type GetBuildsBuildIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBuildsBuildIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildsBuildIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchBuildsBuildIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchBuildsBuildIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchBuildsBuildIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildsBuildIdLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildLogs
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBuildsBuildIdLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildsBuildIdLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnvironmentList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEnvironmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Environment
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostEnvironmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEnvironmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvironmentsEnvironmentIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteEnvironmentsEnvironmentIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvironmentsEnvironmentIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentsEnvironmentIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
	JSON404      *ErrorResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentsEnvironmentIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentsEnvironmentIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchEnvironmentsEnvironmentIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
	JSON404      *ErrorResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchEnvironmentsEnvironmentIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchEnvironmentsEnvironmentIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentsEnvironmentIdBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentsEnvironmentIdBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentsEnvironmentIdBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEnvironmentsEnvironmentIdBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Build
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostEnvironmentsEnvironmentIdBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEnvironmentsEnvironmentIdBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsProjectIdSessionLaunchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLaunchersList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetProjectsProjectIdSessionLaunchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsProjectIdSessionLaunchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionLaunchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLaunchersList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSessionLaunchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionLaunchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSessionLaunchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionLauncher
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostSessionLaunchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSessionLaunchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSessionLaunchersLauncherIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSessionLaunchersLauncherIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSessionLaunchersLauncherIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionLaunchersLauncherIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLauncher
	JSON404      *ErrorResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSessionLaunchersLauncherIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionLaunchersLauncherIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSessionLaunchersLauncherIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLauncher
	JSON404      *ErrorResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchSessionLaunchersLauncherIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSessionLaunchersLauncherIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBuildsBuildIdWithResponse request returning *GetBuildsBuildIdResponse
func (c *ClientWithResponses) GetBuildsBuildIdWithResponse(ctx context.Context, buildId Ulid, reqEditors ...RequestEditorFn) (*GetBuildsBuildIdResponse, error) {
	rsp, err := c.GetBuildsBuildId(ctx, buildId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildsBuildIdResponse(rsp)
}

// PatchBuildsBuildIdWithBodyWithResponse request with arbitrary body returning *PatchBuildsBuildIdResponse
func (c *ClientWithResponses) PatchBuildsBuildIdWithBodyWithResponse(ctx context.Context, buildId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBuildsBuildIdResponse, error) {
	rsp, err := c.PatchBuildsBuildIdWithBody(ctx, buildId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBuildsBuildIdResponse(rsp)
}

func (c *ClientWithResponses) PatchBuildsBuildIdWithResponse(ctx context.Context, buildId Ulid, body PatchBuildsBuildIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBuildsBuildIdResponse, error) {
	rsp, err := c.PatchBuildsBuildId(ctx, buildId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBuildsBuildIdResponse(rsp)
}

// GetBuildsBuildIdLogsWithResponse request returning *GetBuildsBuildIdLogsResponse
func (c *ClientWithResponses) GetBuildsBuildIdLogsWithResponse(ctx context.Context, buildId Ulid, params *GetBuildsBuildIdLogsParams, reqEditors ...RequestEditorFn) (*GetBuildsBuildIdLogsResponse, error) {
	rsp, err := c.GetBuildsBuildIdLogs(ctx, buildId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildsBuildIdLogsResponse(rsp)
}

// GetEnvironmentsWithResponse request returning *GetEnvironmentsResponse
func (c *ClientWithResponses) GetEnvironmentsWithResponse(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*GetEnvironmentsResponse, error) {
	rsp, err := c.GetEnvironments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentsResponse(rsp)
}

// PostEnvironmentsWithBodyWithResponse request with arbitrary body returning *PostEnvironmentsResponse
func (c *ClientWithResponses) PostEnvironmentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEnvironmentsResponse, error) {
	rsp, err := c.PostEnvironmentsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEnvironmentsResponse(rsp)
}

func (c *ClientWithResponses) PostEnvironmentsWithResponse(ctx context.Context, body PostEnvironmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEnvironmentsResponse, error) {
	rsp, err := c.PostEnvironments(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEnvironmentsResponse(rsp)
}

// DeleteEnvironmentsEnvironmentIdWithResponse request returning *DeleteEnvironmentsEnvironmentIdResponse
func (c *ClientWithResponses) DeleteEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*DeleteEnvironmentsEnvironmentIdResponse, error) {
	rsp, err := c.DeleteEnvironmentsEnvironmentId(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvironmentsEnvironmentIdResponse(rsp)
}

// GetEnvironmentsEnvironmentIdWithResponse request returning *GetEnvironmentsEnvironmentIdResponse
func (c *ClientWithResponses) GetEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*GetEnvironmentsEnvironmentIdResponse, error) {
	rsp, err := c.GetEnvironmentsEnvironmentId(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentsEnvironmentIdResponse(rsp)
}

// PatchEnvironmentsEnvironmentIdWithBodyWithResponse request with arbitrary body returning *PatchEnvironmentsEnvironmentIdResponse
func (c *ClientWithResponses) PatchEnvironmentsEnvironmentIdWithBodyWithResponse(ctx context.Context, environmentId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEnvironmentsEnvironmentIdResponse, error) {
	rsp, err := c.PatchEnvironmentsEnvironmentIdWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEnvironmentsEnvironmentIdResponse(rsp)
}

func (c *ClientWithResponses) PatchEnvironmentsEnvironmentIdWithResponse(ctx context.Context, environmentId Ulid, body PatchEnvironmentsEnvironmentIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEnvironmentsEnvironmentIdResponse, error) {
	rsp, err := c.PatchEnvironmentsEnvironmentId(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEnvironmentsEnvironmentIdResponse(rsp)
}

// GetEnvironmentsEnvironmentIdBuildsWithResponse request returning *GetEnvironmentsEnvironmentIdBuildsResponse
func (c *ClientWithResponses) GetEnvironmentsEnvironmentIdBuildsWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*GetEnvironmentsEnvironmentIdBuildsResponse, error) {
	rsp, err := c.GetEnvironmentsEnvironmentIdBuilds(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentsEnvironmentIdBuildsResponse(rsp)
}

// PostEnvironmentsEnvironmentIdBuildsWithResponse request returning *PostEnvironmentsEnvironmentIdBuildsResponse
func (c *ClientWithResponses) PostEnvironmentsEnvironmentIdBuildsWithResponse(ctx context.Context, environmentId Ulid, reqEditors ...RequestEditorFn) (*PostEnvironmentsEnvironmentIdBuildsResponse, error) {
	rsp, err := c.PostEnvironmentsEnvironmentIdBuilds(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEnvironmentsEnvironmentIdBuildsResponse(rsp)
}

// GetProjectsProjectIdSessionLaunchersWithResponse request returning *GetProjectsProjectIdSessionLaunchersResponse
func (c *ClientWithResponses) GetProjectsProjectIdSessionLaunchersWithResponse(ctx context.Context, projectId Ulid, reqEditors ...RequestEditorFn) (*GetProjectsProjectIdSessionLaunchersResponse, error) {
	rsp, err := c.GetProjectsProjectIdSessionLaunchers(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsProjectIdSessionLaunchersResponse(rsp)
}

// GetSessionLaunchersWithResponse request returning *GetSessionLaunchersResponse
func (c *ClientWithResponses) GetSessionLaunchersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionLaunchersResponse, error) {
	rsp, err := c.GetSessionLaunchers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionLaunchersResponse(rsp)
}

// PostSessionLaunchersWithBodyWithResponse request with arbitrary body returning *PostSessionLaunchersResponse
func (c *ClientWithResponses) PostSessionLaunchersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSessionLaunchersResponse, error) {
	rsp, err := c.PostSessionLaunchersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSessionLaunchersResponse(rsp)
}

func (c *ClientWithResponses) PostSessionLaunchersWithResponse(ctx context.Context, body PostSessionLaunchersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSessionLaunchersResponse, error) {
	rsp, err := c.PostSessionLaunchers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSessionLaunchersResponse(rsp)
}

// DeleteSessionLaunchersLauncherIdWithResponse request returning *DeleteSessionLaunchersLauncherIdResponse
func (c *ClientWithResponses) DeleteSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*DeleteSessionLaunchersLauncherIdResponse, error) {
	rsp, err := c.DeleteSessionLaunchersLauncherId(ctx, launcherId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSessionLaunchersLauncherIdResponse(rsp)
}

// GetSessionLaunchersLauncherIdWithResponse request returning *GetSessionLaunchersLauncherIdResponse
func (c *ClientWithResponses) GetSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, reqEditors ...RequestEditorFn) (*GetSessionLaunchersLauncherIdResponse, error) {
	rsp, err := c.GetSessionLaunchersLauncherId(ctx, launcherId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionLaunchersLauncherIdResponse(rsp)
}

// PatchSessionLaunchersLauncherIdWithBodyWithResponse request with arbitrary body returning *PatchSessionLaunchersLauncherIdResponse
func (c *ClientWithResponses) PatchSessionLaunchersLauncherIdWithBodyWithResponse(ctx context.Context, launcherId Ulid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSessionLaunchersLauncherIdResponse, error) {
	rsp, err := c.PatchSessionLaunchersLauncherIdWithBody(ctx, launcherId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSessionLaunchersLauncherIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSessionLaunchersLauncherIdWithResponse(ctx context.Context, launcherId Ulid, body PatchSessionLaunchersLauncherIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSessionLaunchersLauncherIdResponse, error) {
	rsp, err := c.PatchSessionLaunchersLauncherId(ctx, launcherId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSessionLaunchersLauncherIdResponse(rsp)
}

// ParseGetBuildsBuildIdResponse parses an HTTP response from a GetBuildsBuildIdWithResponse call
func ParseGetBuildsBuildIdResponse(rsp *http.Response) (*GetBuildsBuildIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildsBuildIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchBuildsBuildIdResponse parses an HTTP response from a PatchBuildsBuildIdWithResponse call
func ParsePatchBuildsBuildIdResponse(rsp *http.Response) (*PatchBuildsBuildIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchBuildsBuildIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBuildsBuildIdLogsResponse parses an HTTP response from a GetBuildsBuildIdLogsWithResponse call
func ParseGetBuildsBuildIdLogsResponse(rsp *http.Response) (*GetBuildsBuildIdLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildsBuildIdLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildLogs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentsResponse parses an HTTP response from a GetEnvironmentsWithResponse call
func ParseGetEnvironmentsResponse(rsp *http.Response) (*GetEnvironmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnvironmentList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEnvironmentsResponse parses an HTTP response from a PostEnvironmentsWithResponse call
func ParsePostEnvironmentsResponse(rsp *http.Response) (*PostEnvironmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEnvironmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEnvironmentsEnvironmentIdResponse parses an HTTP response from a DeleteEnvironmentsEnvironmentIdWithResponse call
func ParseDeleteEnvironmentsEnvironmentIdResponse(rsp *http.Response) (*DeleteEnvironmentsEnvironmentIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvironmentsEnvironmentIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentsEnvironmentIdResponse parses an HTTP response from a GetEnvironmentsEnvironmentIdWithResponse call
func ParseGetEnvironmentsEnvironmentIdResponse(rsp *http.Response) (*GetEnvironmentsEnvironmentIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentsEnvironmentIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchEnvironmentsEnvironmentIdResponse parses an HTTP response from a PatchEnvironmentsEnvironmentIdWithResponse call
func ParsePatchEnvironmentsEnvironmentIdResponse(rsp *http.Response) (*PatchEnvironmentsEnvironmentIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchEnvironmentsEnvironmentIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentsEnvironmentIdBuildsResponse parses an HTTP response from a GetEnvironmentsEnvironmentIdBuildsWithResponse call
func ParseGetEnvironmentsEnvironmentIdBuildsResponse(rsp *http.Response) (*GetEnvironmentsEnvironmentIdBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentsEnvironmentIdBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEnvironmentsEnvironmentIdBuildsResponse parses an HTTP response from a PostEnvironmentsEnvironmentIdBuildsWithResponse call
func ParsePostEnvironmentsEnvironmentIdBuildsResponse(rsp *http.Response) (*PostEnvironmentsEnvironmentIdBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEnvironmentsEnvironmentIdBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectsProjectIdSessionLaunchersResponse parses an HTTP response from a GetProjectsProjectIdSessionLaunchersWithResponse call
func ParseGetProjectsProjectIdSessionLaunchersResponse(rsp *http.Response) (*GetProjectsProjectIdSessionLaunchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsProjectIdSessionLaunchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLaunchersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSessionLaunchersResponse parses an HTTP response from a GetSessionLaunchersWithResponse call
func ParseGetSessionLaunchersResponse(rsp *http.Response) (*GetSessionLaunchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionLaunchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLaunchersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSessionLaunchersResponse parses an HTTP response from a PostSessionLaunchersWithResponse call
func ParsePostSessionLaunchersResponse(rsp *http.Response) (*PostSessionLaunchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSessionLaunchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionLauncher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSessionLaunchersLauncherIdResponse parses an HTTP response from a DeleteSessionLaunchersLauncherIdWithResponse call
func ParseDeleteSessionLaunchersLauncherIdResponse(rsp *http.Response) (*DeleteSessionLaunchersLauncherIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSessionLaunchersLauncherIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSessionLaunchersLauncherIdResponse parses an HTTP response from a GetSessionLaunchersLauncherIdWithResponse call
func ParseGetSessionLaunchersLauncherIdResponse(rsp *http.Response) (*GetSessionLaunchersLauncherIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionLaunchersLauncherIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLauncher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchSessionLaunchersLauncherIdResponse parses an HTTP response from a PatchSessionLaunchersLauncherIdWithResponse call
func ParsePatchSessionLaunchersLauncherIdResponse(rsp *http.Response) (*PatchSessionLaunchersLauncherIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSessionLaunchersLauncherIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLauncher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//xpv+S6tbAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
